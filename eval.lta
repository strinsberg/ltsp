(lt64-asm-mod
;; TODO there is no error checking or handling in the eval and apply
;; subroutines. Currently most errors are in the reading phase, but
;; as we go on at least a few errors will be introduced in different
;; places and all the code that calls an eval or an application will need
;; to either handle or pass on errors when they happen.
;; TODO each subroutine needs some documentation to at least say what
;; each one expects on the stack and what each one leaves on the stack.
;; And with the addition of ENV they all might need adjustment to their
;; documentation.

;; Takes an env and then a form to evaluate
;; Leaves a (possibly new) env and the result of evaluating the form
(proc  eval/form
       :second :push number/number? :call
         :push eval-form-number :branch
       :second :push eval/atom? :call
         :push eval-form-symbol :branch
       ;; else is list/function application
       :push eval/apply :call
       :ret
:label eval-form-number
       ;; just leave it all alone
       :ret
:label eval-form-symbol
       :second :second
       :push env/find :call
       :first :!false :eq
         :push eval-form-symbol-undefined :branch
       :rot :pop :swap
       :ret
:label eval-form-symbol-undefined
       :pop
       :push symbol-unfound-error :prnmem-lb
       :swap :push sym/print-name :call :!prn-nl
       :!error :swap :ret
       ;; This is still unhandled in all of the other evals and possibly print
)

;; Takes and env and  an address of a pair and applies the car
;; of the pair as a function on the cdr. Leaves the env and the
;; result's address.
(proc  eval/apply
       :second :!pair/car
       :first :push eval/basic-form? :call
         :push eval-apply-basic-form :branch
       :first :push eval/special-form? :call
         :push eval-apply-special-form :branch
       ;; else it should eval to a proc to be applied
       :swap :push eval/form :call
       :second :!proc/procedure?
         :push eval-apply-procedure :branch
       :second :!sub/subroutine?
         :push eval-apply-subroutine :branch
       ;; it is not a proc and cannot be applied
       :push cannot-apply :prnmem-lb
       :second :push debug-form :call
       :rot :pop :rot :pop
       :!ERROR :swap
       :ret

:label eval-apply-basic-form
       :push eval/apply-basic :call
       :ret
:label eval-apply-special-form
       :push eval/apply-special :call
       :ret
:label eval-apply-procedure
       :rot :!pair/cdr :swap  ;; get the function arguments from the pair
       :push eval/apply-procedure :call
       :ret
:label eval-apply-subroutine
       :rot :!pair/cdr :swap
       ;; The address left from the eval should be the label
       ;; of the subroutine in program memory so we just call it
       ;; on the env and arg list
       :rot :!sub/label :call
       :ret
)

;; Takes an env and a list of forms and leaves the env and a new list with
;; all the evaluated forms. Basically (map eval args).
(proc  eval/list
       :push 0  ;; sentinal stopping value
       :rot :rot
       ;; Eval each list element and put result under env and list
:label eval-list-eval
       :second :!NIL :eq
         :push eval-list-eval-end :branch
       :second :!pair/car :swap
       :push eval/form :call
       :rot :!pair/cdr :swap
       :push eval-list-eval :jump

:label eval-list-eval-end
       :swap  ;; bring the NIL to top
       ;; Pull up next evalled item and create pair with the item as car
       ;; and the existing top as cdr
:label eval-list-new-list
       :!third :!zero?
         :push eval-list-end :branch
       :rot :swap
       :push pair/create :call
       :push eval-list-new-list :jump

:label eval-list-end
       :rot :pop  ;; remove 0
       :swap
       :ret
)


;; Basic Forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(proc  eval/basic-form?
      :first :!QUOTE :eq
        :second :!ATOM? :eq
        :or
      :swap :pop
      :ret
)

;; Takes a the address of a basic function symbol and the
;; pair for the function application of that symbol and applies the
;; appropriate function to the arguments.
;; Leaves the result's address.
(proc  eval/apply-basic
       :first :!QUOTE :eq
         :push eval-apply-basic-quote :branch
       :first :!ATOM? :eq
         :push eval-apply-basic-atom? :branch
       ;; Else it was not a basic form TODO ERROR? and crash?
       :rot :pop :pop :!NIL :swap
       :ret

:label eval-apply-basic-quote
       :pop :swap :!pair/cdr :!pair/car
       :swap
       :ret
:label eval-apply-basic-atom?
       :pop :push eval/apply-atom? :call
       :ret
)

(proc  eval/apply-car
       :second :push eval/first-arg :call
       :second :push eval/atom? :call
         :push eval-pair-car-nil :branch
       :rot :pop :swap :!pair/car :swap
       :ret
:label eval-pair-car-nil
       :rot :pop :!NIL :swap :ret
)

(proc  eval/apply-cdr
       :second :push eval/first-arg :call
       :second :push eval/atom? :call
         :push eval-pair-cdr-nil :branch
       :rot :pop :swap :!pair/cdr :swap
       :ret
:label eval-pair-cdr-nil
       :rot :pop :swap :!NIL :swap :ret
)

(proc  eval/apply-cons
       :second :push eval/first-arg :call
       :!third :push eval/second-arg :call
       :dswap :swap :pop :rot
       :push alloc/new-pair :call
       :second :push eval/atom? :call
         :push eval-pair-cons-dotted :branch
       :push pair/make :call
       :push eval-pair-cons-finish :jump

:label eval-pair-cons-dotted
       :push pair/make-dotted :call
       ;; fallthrough
:label eval-pair-cons-finish
       :rot :second :!pair/set-car
       :swap :second :!pair/set-cdr
       :swap :ret
)

(proc  eval/apply-atom?
       :second :push eval/first-arg :call
       :rot :pop
       :second :push eval/atom? :call
         :push eval-apply-atom?-true :branch
       :swap :pop :!F :swap :ret
:label eval-apply-atom?-true
       :swap :pop :!T :swap :ret
)

(proc  eval/apply-eq?
       :second :push eval/first-arg :call
       :!third :push eval/second-arg :call
       :dswap :swap :pop :rot
       ;; checks dont remove the forms
       :push eval/both-symbols? :call
         :push eval-apply-eq-symbols :branch
       :push eval/both-fixed? :call
         :push eval-apply-eq-fixed :branch
       :push eval/both-numbers? :call
         :push eval-apply-eq-numbers :branch
       :pop :pop
       :!F :swap :ret

:label eval-apply-eq-symbols
       :eq :push eval/bool-to-T-F :call
       :swap :ret
:label eval-apply-eq-fixed
       :!number/value
       :rot :!number/value
       :deq :!->word :push eval/bool-to-T-F :call
       :swap :ret
:label eval-apply-eq-numbers
       :push eval/get-number-value-as-int :call
       :rot
       :push eval/get-number-value-as-int :call
       :deq :!->word :push eval/bool-to-T-F :call
       :swap :ret
)


;; Special forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(proc  eval/special-form?
       :first :!COND :eq
         :second :!DEFINE :eq
         :or :second :!LET :eq
         :or :second :!LAMBDA :eq
         :or
       :swap :pop
       :ret
)

;; Takes a the address of a special form symbol and the
;; pair for the function application of that symbol and applies the
;; appropriate function to the arguments.
;; Leaves the result's address.
(proc  eval/apply-special
       :first :!COND :eq
         :push eval-apply-special-cond :branch
       :first :!DEFINE :eq
         :push eval-apply-special-define :branch
       :first :!LET :eq
         :push eval-apply-special-let :branch
       :first :!LAMBDA :eq
         :push eval-apply-special-lambda :branch
       ;; Else it was not a special form TODO ERROR? crash?
       :rot :pop :pop :!NIL :swap
       :ret
:label eval-apply-special-cond
       :pop :swap :!pair/cdr :swap
       :push eval/apply-cond :call
       :ret
:label eval-apply-special-define
       :pop :push eval/apply-define :call
       :ret
:label eval-apply-special-let
       :pop :push eval/apply-let :call
       :ret
:label eval-apply-special-lambda
       :pop :push eval/apply-lambda :call
       :ret
)

;; Takes the list of condition, action pairs from a cond form
;; Leaves the result of the first action that evaluated as not NIL or F.
;; If no condition evaluates to a truthy value leaves NIL
(proc  eval/apply-cond
:label eval-apply-cond-pairs-loop
       :second :!NIL :eq
         :push eval-apply-cond-none :branch
       :second :!pair/car :!pair/car :swap
       :push eval/form :call
       :swap :push eval/falsy? :call :!not
         :push eval-apply-cond-true :branch
       ;; else the condition was not met
       :swap :!pair/cdr :swap
       :push eval-apply-cond-pairs-loop :jump

:label eval-apply-cond-none
       :ret
:label eval-apply-cond-true
       :swap :!pair/car ;; the condition, action pair
       :!pair/cdr :!pair/car ;; the action
       :swap :push eval/form :call
       :ret
)


;; Takes an env and a define form. Add the binding to the front of the
;; builtin bindings. Leaves T if succesful, otherwise :!error.
(proc  eval/apply-define
       :second :!pair/cdr :!pair/car
       :first :!sym/symbol? :!not
         :push eval-apply-define-not-symbol :branch
       :first :!third
       :push env/find :call :!false :eq :!not
         :push eval-apply-define-already-here :branch
       :swap :rot :push eval/second-arg :call
       :!third :!third
       :push env/add-define :call
       :second :!proc/procedure?
         :push eval-apply-define-update-proc-env :branch
       :swap :pop :swap :pop
       :!T :swap
       :ret

:label eval-apply-define-not-symbol
       :push invalid-define-target :prnmem-lb
       :push debug-form :call
       :swap :pop :!error :swap :ret
:label eval-apply-define-already-here
       :push symbol-already-defined :prnmem-lb
       :push sym/print-name :call :!prn-nl
       :swap :pop :!error :swap :ret
:label eval-apply-define-update-proc-env
       :!third :!third :first :!proc/env
       :push env/add :call
       :rot :!proc/set-env
       :!T :swap
       :ret
)

;; Takes an env and a let form and evaluates the body with all local bindings
;; made. Leaves the parent env and the result.
(proc  eval/apply-let
       :swap :second  ;; duplicate env for local use
       :second :!pair/cdr :!pair/car
       :swap
       :push eval/add-let-bindings :call
       :swap :!pair/cdr :!pair/cdr :!pair/car
       :swap
       :push eval/form :call
       :pop :swap  ;; pop local env and put result under parent env
       :ret
)

;; Takes an env and a list of bindings and leaves the updated env.
(proc  eval/add-let-bindings
:label eval-add-let-bindings-loop
       :second :!NIL :eq
         :push eval-add-let-bindings-end :branch
       :second :!pair/car
       :first :!pair/car
       :swap :!pair/cdr :!pair/car
       :rot
       :push eval/form :call
       :push env/add :call
       :swap :!pair/cdr :swap
       :push eval-add-let-bindings-loop :jump

:label eval-add-let-bindings-end
       :swap :pop :ret
)

;; Takes an env and a lambda form and leaves a procedure with a closure
;; around the environment that it was declared in.
(proc  eval/apply-lambda
       :second :!pair/cdr :!pair/car
       :rot :!pair/cdr :!pair/cdr :!pair/car
       :!third ;; duplicate the env to be consumed for setting closure env

       ;; allocate memory, make it a proc
       :push alloc/new-procedure :call
       :push proc/make :call
       :swap :second :!proc/set-env
       :swap :second :!proc/set-body
       :swap :second :!proc/set-params
       :swap
       :ret
)

;; Apply procedures ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Takes an env and the address of a list of procedure arguments and the
;; address of the procedure to apply to those arguments.
;; Leaves the env and the result of the application.
(proc  eval/apply-procedure
       :swap
       :!third :!proc/params
       :!fourth :!proc/env
       :push eval/bind-proc-args :call
       :!third :!proc/body :swap
       :push eval/form :call
       :pop :swap :rot :pop
       :ret
)

;; Takes the proc env, a list of params, a list of arguments, and the parent
;; env and adds bindings to the procedures env. Leaves the updated env and
;; the parent env.
(proc  eval/bind-proc-args
       :!fourth :rpush
:label eval-bind-proc-args-loop
       :second :!NIL :eq
         :!fourth :!NIL :eq
         :or :push eval-bind-proc-args-end :branch
       ;; TODO what if the only one is NIL?
       :second :!pair/car
       :!fourth :!pair/car
       :rgrab :push eval/form :call
       :pop
       :rot
       :push env/add :call
       :rot :!pair/cdr
       :rot :!pair/cdr
       :rot
       :push eval-bind-proc-args-loop :jump

:label eval-bind-proc-args-end
       :rpop :pop
       :swap :pop :swap :pop
       :ret
)

;; Eval helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Take an address and check if it is atom
(proc  eval/atom?
       :first :!sym/symbol?
         :second :!number/int?
         :or :second :!number/fixed?
         :or
       :swap :pop
       :ret
)

;; Takes a form address for a function application, i.e. (func arg arg ...),
;; and the current env underneath it, and leaves the form resulting
;; from the evaluation of the first argument.
(proc  eval/first-arg
       :!pair/cdr :!pair/car :swap
       :push eval/form :call
       :ret
)

;; Takes a form address for a function application, i.e. (func arg arg ...),
;; and the current env underneath it, and leaves the form resulting
;; from the evaluation of the second argument.
(proc  eval/second-arg
       :!pair/cdr :!pair/cdr :!pair/car :swap
       :push eval/form :call
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both symbols and 0 otherwise.
(proc  eval/both-symbols?
       :second :!sym/symbol?
         :second :!sym/symbol?
         :and
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both fixed point numbers and 0 otherwise.
(proc  eval/both-fixed?
       :second :!number/fixed?
         :second :!number/fixed?
         :and
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both numbers (fixed or int) and 0 otherwise.
(proc  eval/both-numbers?
       :first :!number/int?
         :second :!number/fixed?
         :or
         :push 2 :nth :!number/int?
           :push 3 :nth :!number/fixed?
           :or
         :and
       :ret
)

;; Take the top value and return F if it is :!false (0), otherwise T.
;; For use when some VM check returns 0 or 1 and the subroutine uses this
;; to return T or F.
;; **NOT** for use to check for falsy values when expecting T, F, or NIL.
(proc  eval/bool-to-T-F
       :!false :eq
         :push eval-bool-to-T-F-false :branch
       :!T :ret
:label eval-bool-to-T-F-false
       :!F :ret
)

;; Takes the address of a number and returns the value as an int.
;; If the number is an int just return the value, and if it is fixed then
;; scale it down and return that value.
(proc  eval/get-number-value-as-int
       :first :!number/int?
         :push eval-get-number-value-as-int-is-int :branch
       ;; else number is fixed point
       :!number/value :dpush 1000 :ddiv
       :ret
:label eval-get-number-value-as-int-is-int
       :!number/value :ret
)

;; Takes the address of a number and returns the value as fixed.
;; If the number is alredy fixed just return the value, and if it is an int then
;; scale it up and return that value.
(proc  eval/get-number-value-as-fixed
       :first :!number/fixed?
         :push eval-get-number-value-as-fixed-is-fixed :branch
       ;; else number is fixed point
       :!number/value :dpush 1000 :dmult
       :ret
:label eval-get-number-value-as-fixed-is-fixed
       :!number/value :ret
)

(proc  eval/falsy?
       :first :!F :eq
         :swap :!NIL :eq
         :or
       :ret
)


)

