(lt64-asm-mod

(proc eval/form
      :first :push eval/atom? :call
        :push eval-form-atom :branch
      ;; else is list (for now)
      :push eval/apply :call
      :ret
:label eval-form-atom
      ;; just "return" the atom
      :ret
)

;; Takes an address of a pair and applies the car as a function on the cdr
;; Leaves the result's address.
(proc  eval/apply
       :first :!pair/car
       :first :push eval/basic-form? :call
         :push eval-apply-basic-form :branch
       :first :push eval/special-form? :call
         :push eval-apply-special-form :branch
       :!NIL ;; for now so all lists must be quoted to not be evalled
       :ret

:label eval-apply-basic-form
       :push eval/apply-basic :call
       :ret
:label eval-apply-special-form
       :push eval/apply-special :call
       :ret
)


;; Basic Forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(proc  eval/basic-form?
      :first :!QUOTE :eq
        :second :!CAR :eq
        :or :second :!CDR :eq
        :or :second :!CONS :eq
        :or :second :!ATOM? :eq
        :or :second :!EQ? :eq
        :or
      :swap :pop
      :ret
)

;; Takes a the address of a basic function symbol and the
;; pair for the function application of that symbol and applies the
;; appropriate function to the arguments.
;; Leaves the result's address.
(proc  eval/apply-basic
       :first :!QUOTE :eq
         :push eval-apply-basic-quote :branch
       :first :!CAR :eq
         :push eval-apply-basic-car :branch
       :first :!CDR :eq
         :push eval-apply-basic-cdr :branch
       :first :!CONS :eq
         :push eval-apply-basic-cons :branch
       :first :!ATOM? :eq
         :push eval-apply-basic-atom? :branch
       :first :!EQ? :eq
         :push eval-apply-basic-eq? :branch
       ;; should be unrechable if only called for basic forms
       :pop :pop :!NIL
       :ret

:label eval-apply-basic-quote
       :pop :!pair/cdr :!pair/car
       :ret
:label eval-apply-basic-car
       :pop :push eval/apply-car :call
       :ret
:label eval-apply-basic-cdr
       :pop :push eval/apply-cdr :call
       :ret
:label eval-apply-basic-cons
       :pop :push eval/apply-cons :call
       :ret
:label eval-apply-basic-atom?
       :pop :push eval/apply-atom? :call
       :ret
:label eval-apply-basic-eq?
       :pop :push eval/apply-eq? :call
       :ret
)

(proc  eval/apply-car
       :push eval/first-arg :call
       :first :push eval/atom? :call
         :push eval-pair-car-nil :branch
       :!pair/car
       :ret
:label eval-pair-car-nil
       :pop :!NIL :ret
)

(proc  eval/apply-cdr
       :push eval/first-arg :call
       :first :push eval/atom? :call
         :push eval-pair-cdr-nil :branch
       :!pair/cdr
       :ret
:label eval-pair-cdr-nil
       :pop :!NIL :ret
)

(proc  eval/apply-cons
       :first :push eval/first-arg :call
       :second :push eval/second-arg :call
       :rot :pop
       :push alloc/new-pair :call
       :second :push eval/atom? :call
         :push eval-pair-cons-dotted :branch
       :push pair/make :call
       :push eval-pair-cons-finish :jump

:label eval-pair-cons-dotted
       :push pair/make-dotted :call
       ;; fallthrough
:label eval-pair-cons-finish
       :rot :second :!pair/set-car
       :swap :second :!pair/set-cdr
       :ret
)

(proc  eval/apply-atom?
       :push eval/first-arg :call
       :push eval/atom? :call
         :push eval-apply-atom?-true :branch
       :!F :ret
:label eval-apply-atom?-true
       :!T :ret
)

(proc  eval/apply-eq?
       :first :push eval/first-arg :call
       :second :push eval/second-arg :call
       :rot :pop
       ;; checks dont remove the forms
       :push eval/both-symbols? :call
         :push eval-apply-eq-symbols :branch
       :push eval/both-fixed? :call
         :push eval-apply-eq-fixed :branch
       :push eval/both-numbers? :call
         :push eval-apply-eq-numbers :branch
       :pop :pop
       :!F :ret

:label eval-apply-eq-symbols
       :eq :push eval/bool-to-T-F :call
       :ret
:label eval-apply-eq-fixed
       :!number/value
       :rot :!number/value
       :deq :!->word :push eval/bool-to-T-F :call
       :ret
:label eval-apply-eq-numbers
       :push eval/get-number-value-as-int :call
       :rot
       :push eval/get-number-value-as-int :call
       :deq :!->word :push eval/bool-to-T-F :call
       :ret
)


;; Special forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(proc  eval/special-form?
       :first :!COND :eq
       ;; add lambda, list, define later
       :swap :pop
       :ret
)

;; Takes a the address of a special form symbol and the
;; pair for the function application of that symbol and applies the
;; appropriate function to the arguments.
;; Leaves the result's address.
(proc  eval/apply-special
       :first :!COND :eq
         :push eval-apply-special-cond :branch
       ;; add lambda, list, define later
       :pop :pop :!NIL
       :ret
:label eval-apply-special-cond
       :pop :!pair/cdr
       :push eval/apply-cond :call
       :ret
)

;; Takes the list of condition, action pairs from a cond form
;; Leaves the result of the first action that evaluated as not NIL or F.
;; If no condition evaluates to a truthy value leaves NIL
(proc  eval/apply-cond
:label eval-apply-cond-pairs-loop
       :first :!NIL :eq
         :push eval-apply-cond-none :branch
       :first :!pair/car :!pair/car
       :push eval/form :call
       :push eval/falsy? :call :!not
         :push eval-apply-cond-true :branch
       ;; else the condition was not met
       :!pair/cdr
       :push eval-apply-cond-pairs-loop :jump

:label eval-apply-cond-none
       :ret
:label eval-apply-cond-true
       :!pair/car ;; the condition, action pair
       :!pair/cdr :!pair/car ;; the action
       :push eval/form :call
       :ret
)

(proc  eval/falsy?
       :first :!F :eq
         :swap :!NIL :eq
         :or
       :ret
)


;; Eval helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Take an address and check if it is atom
(proc  eval/atom?
       :first :!sym/symbol?
         :second :!number/int?
         :or :second :!number/fixed?
         :or
       :swap :pop
       :ret
)

;; Takes a form address for a function application, i.e. (func arg arg ...),
;; and leave the form resulting from the evaluation of the first argument.
(proc  eval/first-arg
       :!pair/cdr :!pair/car
       :push eval/form :call
       :ret
)

;; Takes a form address for a function application, i.e. (func arg arg ...),
;; and leave the form resulting from the evaluation of the second argument.
(proc  eval/second-arg
       :!pair/cdr :!pair/cdr :!pair/car
       :push eval/form :call
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both symbols and 0 otherwise.
(proc  eval/both-symbols?
       :second :!sym/symbol?
         :second :!sym/symbol?
         :and
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both fixed point numbers and 0 otherwise.
(proc  eval/both-fixed?
       :second :!number/fixed?
         :second :!number/fixed?
         :and
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both numbers (fixed or int) and 0 otherwise.
(proc  eval/both-numbers?
       :first :!number/int?
         :second :!number/fixed?
         :or
         :push 2 :nth :!number/int?
           :push 3 :nth :!number/fixed?
           :or
         :and
       :ret
)

;; Take the top value and return F if it is :!false (0), otherwise T.
;; For use when some VM check returns 0 or 1 and the subroutine uses this
;; to return T or F.
;; **NOT** for use to check for falsy values when expecting T, F, or NIL.
(proc  eval/bool-to-T-F
       :!false :eq
         :push eval-bool-to-T-F-false :branch
       :!T :ret
:label eval-bool-to-T-F-false
       :!F :ret
)

;; Takes the address of a number and returns the value as an int.
;; If the number is an int just return the value, and if it is fixed then
;; scale it down and return that value.
(proc  eval/get-number-value-as-int
       :first :!number/int?
         :push eval-get-number-value-as-int-is-int :branch
       ;; else number is fixed point
       :!number/value :dpush 1000 :ddiv
       :ret
:label eval-get-number-value-as-int-is-int
       :!number/value :ret
)


)

