(lt64-asm-mod
;; TODO there is no error checking or handling in the eval and apply
;; subroutines. Currently most errors are in the reading phase, but
;; as we go on at least a few errors will be introduced in different
;; places and all the code that calls an eval or an application will need
;; to either handle or pass on errors when they happen.
;; TODO each subroutine needs some documentation to at least say what
;; each one expects on the stack and what each one leaves on the stack.

;; Takes an env and then a form to evaluate
;; Leaves a (possibly new) env and the result of evaluating the form
(proc eval/form
      :second :!NIL :eq
        :push eval-form-symbol :branch ;; later all symbols
      :second :push eval/atom? :call
        :push eval-form-atom :branch
      ;; else is list (for now)
      :push eval/apply :call
      :ret
:label eval-form-atom
      ;; just leave it all alone
      :ret
:label eval-form-symbol
      :second :second
      :push env/find :call
      :first :!false :eq
        :push eval-form-symbol-undefined :branch
      :rot :pop :swap
      :ret
:label eval-form-symbol-undefined
      :pop
      :push symbol-unfound-error :prnmem-lb
      :push sym/print-name :call :!prn-nl
      :!error :rot :pop :swap
      :ret
      ;; This is still unhandled in all of the other evals and possibly print
)

;; Takes and env and  an address of a pair and applies the car
;; of the pair as a function on the cdr. Leaves the env and the
;; result's address.
(proc  eval/apply
       :second :!pair/car
       :first :push eval/basic-form? :call
         :push eval-apply-basic-form :branch
       :first :push eval/special-form? :call
         :push eval-apply-special-form :branch
       :rot :pop :pop
       :!NIL :swap ;; for now so all lists must be quoted to not be evalled
       :ret

:label eval-apply-basic-form
       :push eval/apply-basic :call
       :ret
:label eval-apply-special-form
       :push eval/apply-special :call
       :ret
)


;; Basic Forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(proc  eval/basic-form?
      :first :!QUOTE :eq
        :second :!CAR :eq
        :or :second :!CDR :eq
        :or :second :!CONS :eq
        :or :second :!ATOM? :eq
        :or :second :!EQ? :eq
        :or
      :swap :pop
      :ret
)

;; Takes a the address of a basic function symbol and the
;; pair for the function application of that symbol and applies the
;; appropriate function to the arguments.
;; Leaves the result's address.
(proc  eval/apply-basic
       :first :!QUOTE :eq
         :push eval-apply-basic-quote :branch
       :first :!CAR :eq
         :push eval-apply-basic-car :branch
       :first :!CDR :eq
         :push eval-apply-basic-cdr :branch
       :first :!CONS :eq
         :push eval-apply-basic-cons :branch
       :first :!ATOM? :eq
         :push eval-apply-basic-atom? :branch
       :first :!EQ? :eq
         :push eval-apply-basic-eq? :branch
       ;; should be unrechable if only called for basic forms
       :rot :pop :pop :!NIL :swap
       :ret

:label eval-apply-basic-quote
       :pop :swap :!pair/cdr :!pair/car
       :swap
       :ret
:label eval-apply-basic-car
       :pop :push eval/apply-car :call
       :ret
:label eval-apply-basic-cdr
       :pop :push eval/apply-cdr :call
       :ret
:label eval-apply-basic-cons
       :pop :push eval/apply-cons :call
       :ret
:label eval-apply-basic-atom?
       :pop :push eval/apply-atom? :call
       :ret
:label eval-apply-basic-eq?
       :pop :push eval/apply-eq? :call
       :ret
)

(proc  eval/apply-car
       :second :push eval/first-arg :call
       :second :push eval/atom? :call
         :push eval-pair-car-nil :branch
       :rot :pop :swap :!pair/car :swap
       :ret
:label eval-pair-car-nil
       :rot :pop :!NIL :swap :ret
)

(proc  eval/apply-cdr
       :second :push eval/first-arg :call
       :second :push eval/atom? :call
         :push eval-pair-cdr-nil :branch
       :rot :pop :swap :!pair/cdr :swap
       :ret
:label eval-pair-cdr-nil
       :rot :pop :swap :!NIL :swap :ret
)

(proc  eval/apply-cons
       :second :push eval/first-arg :call
       :!third :push eval/second-arg :call
       :dswap :swap :pop :rot
       :push alloc/new-pair :call
       :second :push eval/atom? :call
         :push eval-pair-cons-dotted :branch
       :push pair/make :call
       :push eval-pair-cons-finish :jump

:label eval-pair-cons-dotted
       :push pair/make-dotted :call
       ;; fallthrough
:label eval-pair-cons-finish
       :rot :second :!pair/set-car
       :swap :second :!pair/set-cdr
       :swap :ret
)

(proc  eval/apply-atom?
       :second :push eval/first-arg :call
       :rot :pop
       :second :push eval/atom? :call
         :push eval-apply-atom?-true :branch
       :swap :pop :!F :swap :ret
:label eval-apply-atom?-true
       :swap :pop :!T :swap :ret
)

(proc  eval/apply-eq?
       :second :push eval/first-arg :call
       :!third :push eval/second-arg :call
       :dswap :swap :pop :rot
       ;; checks dont remove the forms
       :push eval/both-symbols? :call
         :push eval-apply-eq-symbols :branch
       :push eval/both-fixed? :call
         :push eval-apply-eq-fixed :branch
       :push eval/both-numbers? :call
         :push eval-apply-eq-numbers :branch
       :pop :pop
       :!F :swap :ret

:label eval-apply-eq-symbols
       :eq :push eval/bool-to-T-F :call
       :swap :ret
:label eval-apply-eq-fixed
       :!number/value
       :rot :!number/value
       :deq :!->word :push eval/bool-to-T-F :call
       :swap :ret
:label eval-apply-eq-numbers
       :push eval/get-number-value-as-int :call
       :rot
       :push eval/get-number-value-as-int :call
       :deq :!->word :push eval/bool-to-T-F :call
       :swap :ret
)


;; Special forms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(proc  eval/special-form?
       :first :!COND :eq
       ;; add lambda, list, define later
       :swap :pop
       :ret
)

;; Takes a the address of a special form symbol and the
;; pair for the function application of that symbol and applies the
;; appropriate function to the arguments.
;; Leaves the result's address.
(proc  eval/apply-special
       :first :!COND :eq
         :push eval-apply-special-cond :branch
       ;; add lambda, list, define later
       :rot :pop :pop :!NIL :swap
       :ret
:label eval-apply-special-cond
       :pop :swap :!pair/cdr :swap
       :push eval/apply-cond :call
       :ret
)

;; Takes the list of condition, action pairs from a cond form
;; Leaves the result of the first action that evaluated as not NIL or F.
;; If no condition evaluates to a truthy value leaves NIL
(proc  eval/apply-cond
:label eval-apply-cond-pairs-loop
       :second :!NIL :eq
         :push eval-apply-cond-none :branch
       :second :!pair/car :!pair/car :swap
       :push eval/form :call
       :swap :push eval/falsy? :call :!not
         :push eval-apply-cond-true :branch
       ;; else the condition was not met
       :swap :!pair/cdr :swap
       :push eval-apply-cond-pairs-loop :jump

:label eval-apply-cond-none
       :ret
:label eval-apply-cond-true
       :swap :!pair/car ;; the condition, action pair
       :!pair/cdr :!pair/car ;; the action
       :swap :push eval/form :call
       :ret
)


;; Eval helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Take an address and check if it is atom
(proc  eval/atom?
       :first :!sym/symbol?
         :second :!number/int?
         :or :second :!number/fixed?
         :or
       :swap :pop
       :ret
)

;; Takes a form address for a function application, i.e. (func arg arg ...),
;; and leave the form resulting from the evaluation of the first argument.
(proc  eval/first-arg
       :!pair/cdr :!pair/car :swap
       :push eval/form :call
       :ret
)

;; Takes a form address for a function application, i.e. (func arg arg ...),
;; and leave the form resulting from the evaluation of the second argument.
(proc  eval/second-arg
       :!pair/cdr :!pair/cdr :!pair/car :swap
       :push eval/form :call
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both symbols and 0 otherwise.
(proc  eval/both-symbols?
       :second :!sym/symbol?
         :second :!sym/symbol?
         :and
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both fixed point numbers and 0 otherwise.
(proc  eval/both-fixed?
       :second :!number/fixed?
         :second :!number/fixed?
         :and
       :ret
)

;; Uses top two form addresses (does not pop them) and returns 1 if they are
;; both numbers (fixed or int) and 0 otherwise.
(proc  eval/both-numbers?
       :first :!number/int?
         :second :!number/fixed?
         :or
         :push 2 :nth :!number/int?
           :push 3 :nth :!number/fixed?
           :or
         :and
       :ret
)

;; Take the top value and return F if it is :!false (0), otherwise T.
;; For use when some VM check returns 0 or 1 and the subroutine uses this
;; to return T or F.
;; **NOT** for use to check for falsy values when expecting T, F, or NIL.
(proc  eval/bool-to-T-F
       :!false :eq
         :push eval-bool-to-T-F-false :branch
       :!T :ret
:label eval-bool-to-T-F-false
       :!F :ret
)

;; Takes the address of a number and returns the value as an int.
;; If the number is an int just return the value, and if it is fixed then
;; scale it down and return that value.
(proc  eval/get-number-value-as-int
       :first :!number/int?
         :push eval-get-number-value-as-int-is-int :branch
       ;; else number is fixed point
       :!number/value :dpush 1000 :ddiv
       :ret
:label eval-get-number-value-as-int-is-int
       :!number/value :ret
)

(proc  eval/falsy?
       :first :!F :eq
         :swap :!NIL :eq
         :or
       :ret
)


)

