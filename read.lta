(lt64-asm-mod
  ;; Read a new form from stdin and store the structured data
  ;; Leaves the address of the new form on the stack
  (proc read/form
    :push read/symbol :call
    :ret)

  ;; Read the next symbol and store up to its first 6 chars
  ;; in a newly allocated symbol. Leave stop char on the stack.
  (proc read/symbol
    :push read/chars :call              ;; read chars into buffer until stop
    ;; TODO before allocating a new symbol we need to search
    ;; to see if it is already in the list
    ;; Need a set of procedures for dealing with the sym list
    :push alloc/new-symbol :call
    :first :push 2 :add                 ;; sym string is at sym + 2
    :push 3 :buf-to-mem                 ;; copy 3 words (6chars) into sym

    :!alloc/list-head                   ;; address of next sym
    :second :push 5 :add :store-lb      ;; set sym to point to next sym
    :first :!alloc/set-list-head        ;; list head point to new sym
    :ret)

  ;; Read chars into the buffer until we see one of the following:
  ;; lp=40, rp=41, .=46, ,=44, ;=59, '=39,
  ;; space=32, tab=9, newline=10
  ;; Leave stop char on stack
  (proc read/chars
    :push 0  ;; delimeter on stack

    ;; Read all chars up to stopping point onto stack
    :label chars-read-loop
    ;; TODO make this check and the other two use a subroutine that checks
    ;; to see if it is a stopping char not just a newline
    :readch :first :push 10 :eq :!zero?
    :push chars-read-loop :branch

    ;; Move all chars onto the return stack to reverse them
    :label chars-reverse-loop
    :rpush :rgrab :!zero? :!zero?
    :push chars-reverse-loop :branch
    :rpop :pop  ;; get rid of the 0 delimeter

    ;; Take 2 chars at a time, pack them, move them to buffer
    ;; If one of the pulled chars is the stoping char
    ;; save it and store last char or 0 into buffer
    :push 0
    :label chars-buf-loop
    :rpop :rpop
    :second :push 10 :eq :push chars-first-stop :branch
    :first :push 10 :eq :push chars-second-stop :branch
    :swap :pack :second :bufstore
    :!inc :push chars-buf-loop :jump

    :label chars-first-stop
    :rpush
    :push 0 :swap  ;; swap lets us fall through without jumping

    :label chars-second-stop
    :swap
    :rot :bufstore

    ;; The stopping char is on the stack
    :ret)
  
)

