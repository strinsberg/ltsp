(lt64-asm-mod
  ;; TODO need to handle EOF when reading
  ;; Also somehow for the top level read to quit the interpreter

  ;; Read a new form from stdin and store the structured data
  ;; Leaves the address of the new form on the stack
  (proc read/form
    :push read/eat-ws :call

    ;; Check for what to read
    :first :!lp :eq
    :push form-is-pair :branch
    :first :push read/digit? :call
    :push form-is-number :branch
    :first :push read/valid-symbol-char? :call
    :push form-is-symbol :branch

    ;; Not a valid character to start a form
    :push invalid-start-char :prnmem-lb
    :!quote :prnch :first :prnch :!quote :prnch
    :!lp :prnch :wprn :!rp :prnch :!prn-nl
    ;; For the repl errors end the whole read
    ;; For files we would just quit, or do error recovery
    :readln :!nil :ret

    :label form-is-pair
    :pop                               ;; discard the (
    :push read/pair :call
    :push read-form-end :jump

    :label form-is-number
    :push read/number :call
    :push read-form-end :jump

    :label form-is-symbol
    :push read/symbol :call

    :label read-form-end
    ;; cleanup?
    :ret)

  ;; Eats all whitespace in stdin and leaves the first non whitespace
  ;; char on the stack.
  (proc read/eat-ws
    :readch
    :ret)

  ;; Symbol reading ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (macro :!init-rcount :push 0 :rpush)
  (macro :!inc-rcount :rpop :push 1 :add :rpush)
  (macro :!end-rcount :rpop :pop)
  (macro :!eq-rcount :rgrab :eq)
  (macro :!add-rcount :rgrab :add)

  ;; Tell if the char on the stack can be in a symbol.
  ;; Ignores chars that can't start a symbol and that would stop a symbol
  ;; because they will be checked somewhere else.
  ;; Leaves 1 for true and 0 for false
  (proc read/valid-symbol-char?
    :!init-rcount
    :label valid-symbol-char-loop
    :push invalid-sym :!add-rcount :load-lb
    :first :!zero? :push valid-symbol-char-true :branch
    :second :eq :push valid-symbol-char-false :branch
    :!inc-rcount
    :push valid-symbol-char-loop :jump

    :label valid-symbol-char-true
    :pop                               ;; remove the 0 that ended the list
    :push 1 :!end-rcount :ret

    :label valid-symbol-char-false
    :push 0 :!end-rcount
    :ret)

  ;; Read the next symbol and store up to its first 6 chars
  ;; in a newly allocated symbol. Leave stop char on the stack.
  (proc read/symbol
    :push read/sym-chars :call         ;; read chars into buffer until stop

    :bfp :push symlist/has-name? :call
    :first :push symbol-already-there :branch

    :pop :push alloc/new-symbol :call
    :bfp :second :push sym/set-name :call

    :label symbol-already-there
    :first :push symlist/add :call
    :ret)

  ;; TODO the char reading could be better using the :readch-buf but it will
  ;; still need to pull chars out of the buffer to check for the stop
  ;; char in both bytes, so might be as easy to just duplicate the
  ;; readch-buf op in here reading chars in and packing them if needed
  ;; kind of like the print-name, but in a loop

  ;; Read chars into the buffer until we see one of the following:
  ;; Expects the first char is on the stack already.
  ;; Leaves stop char on stack.
  (proc read/sym-chars
    :push 0 :swap                      ;; delimeter on stack under first char

    ;; Read all chars up to stopping point onto stack
    :label chars-read-loop
    ;; TODO check to make sure the chars are valid in a symbol
    ;; TODO make this check and the other two use a subroutine that checks
    ;; to see if it is a stopping char not just a newline
    :readch :first :push 10 :eq :!not
    :push chars-read-loop :branch

    ;; Move all chars onto the return stack to reverse them
    :label chars-reverse-loop
    :rpush :rgrab
    :push chars-reverse-loop :branch
    :rpop :pop  ;; get rid of the 0 delimeter

    ;; Take 2 chars at a time, pack them, move them to buffer
    ;; If one of the pulled chars is the stoping char
    ;; save it and store last char or 0 into buffer
    :push 0
    :label chars-buf-loop
    :rpop :rpop
    :second :push 10 :eq :push chars-first-stop :branch
    :first :push 10 :eq :push chars-second-stop :branch
    :swap :pack :second :bufstore
    :!inc :push chars-buf-loop :jump

    :label chars-first-stop
    :rpush
    :push 0 :swap  ;; swap lets us fall through without jumping

    :label chars-second-stop
    :swap
    :rot :bufstore

    ;; The stopping char is on the stack
    :ret)


  ;; Pair reading ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Read a pair and leave the address on the stack.
  ;; Does not expect anything on the stack.
  (proc read/pair
    :!nil
    :ret)


  ;; Number reading ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (proc read/digit?
    :push 0
    :ret)

  ;; Read a number and leave the address on the stack.
  ;; Expects the first character on the stack.
  (proc read/number
    :!nil
    :ret)
)

