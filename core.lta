(lt64-asm-mod

;; Loads all of the data for core functions that use assembled subroutines
(proc  core/load-all
       ;; Elementary
       :push core/make-cons :call
       :push core/make-car :call
       :push core/make-cdr :call

       ;; Arithmetic
       :push core/make-add :call
       :push core/make-sub :call
       :push core/make-mult :call
       :push core/make-div :call
       :ret
)

;; Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Takes a subroutine label and expects a symbol name in the buffer.
;; Creates all objects necessary to add the subroutine to the the buitin
;; list of definitions.
(proc  core/create
       :push core/create-symbol :call
       :swap :second
       :push core/create-subroutine :call
       :push env/add-define :call
       :ret
)

;; Creates a new symbol from the name in the buffer at :bfp.
;; Takes nothing and leaves the new symbol address.
(proc  core/create-symbol
       :push alloc/new-symbol :call
       :push sym/make :call
       :bfp :second :push sym/set-name :call
       :first :push symlist/add :call
       :ret
)

;; Takes a symbol address and a label off of the stack and creates a
;; subroutine element. Leaves the address of the new element.
(proc  core/create-subroutine
       :push alloc/new-subroutine :call
       :push 0x0600 :second :!sub/set-info
       :swap :second :!sub/set-symbol
       :swap :second :!sub/set-label
       :ret
)
(macro :!sub/info :load-lb)
(macro :!sub/label :push 1 :add :load-lb)
(macro :!sub/symbol :push 2 :add :load-lb)
(macro :!sub/set-info :store-lb)
(macro :!sub/set-label :push 1 :add :store-lb)
(macro :!sub/set-symbol :push 2 :add :store-lb)
(macro :!sub/subroutine? :load-lb :push 8 :sr :push 0x06 :eq)


;; Addition function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates the add function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-add
       :push 0x6461 :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/add
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of adding the
;; arguments together.
(proc  core/add
       :dpush 0 :drpush
       :swap
:label core-add-int-loop
       :first :!NIL :eq
         :push core-add-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-add-not-number :branch
       :first :!number/fixed?
         :push core-add-fixed-start :branch
       :!number/value :drpop :dadd :drpush
       :!pair/cdr
       :push core-add-int-loop :jump

:label core-add-int-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-add-fixed-start
       :!number/value
       :drpop :dpush 1000 :dmult :dadd :drpush
       :!pair/cdr
:label core-add-fixed-loop
       :first :!NIL :eq
         :push core-add-fixed-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-add-not-number :branch
       :push eval/get-number-value-as-fixed :call
       :drpop :dadd :drpush
       :!pair/cdr
       :push core-add-fixed-loop :jump

:label core-add-fixed-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret
       :push env/add-define :call

:label core-add-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop
       :!error :swap :ret
)

;; Subtraction function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-sub
       :push 0x7573 :push 0 :bufstore
       :push 0x0062 :push 1 :bufstore
       :push core/sub
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of subtracting
;; all arguments from the first.
(proc  core/sub
       ;; All this is because we keep the first number positive
       :swap
       :first :!NIL :eq
         :push core-sub-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-sub-not-number :branch
       :first :!number/fixed?
         :push core-sub-fixed-first :branch
       :!number/value :drpush
       :!pair/cdr
:label core-sub-int-loop
       :first :!NIL :eq
         :push core-sub-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-sub-not-number :branch
       :first :!number/fixed?
         :push core-sub-fixed-start :branch
       :!number/value :drpop :dswap :dsub :drpush
       :!pair/cdr
       :push core-sub-int-loop :jump

:label core-sub-int-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-sub-fixed-first
       :!number/value :drpush
       :!pair/cdr
       :push core-sub-fixed-loop :jump
:label core-sub-fixed-start
       :!number/value
       :drpop :dpush 1000 :dmult
       :dswap :dsub :drpush
       :!pair/cdr
:label core-sub-fixed-loop
       :first :!NIL :eq
         :push core-sub-fixed-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-sub-not-number :branch
       :push eval/get-number-value-as-fixed :call
       :drpop :dswap :dsub :drpush
       :!pair/cdr
       :push core-sub-fixed-loop :jump

:label core-sub-fixed-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret

:label core-sub-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop
       :!error :swap :ret
)


;; Mutiplication function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates the mult function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-mult
       :push 0x756d :push 0 :bufstore
       :push 0x746c :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/mult
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of multiplying
;; the arguments together.
(proc  core/mult
       :dpush 1 :drpush
       :swap
:label core-mult-int-loop
       :first :!NIL :eq
         :push core-mult-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-mult-not-number :branch
       :first :!number/fixed?
         :push core-mult-fixed-start :branch
       :!number/value :drpop :dmult :drpush
       :!pair/cdr
       :push core-mult-int-loop :jump

:label core-mult-int-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-mult-fixed-start
       :!number/value
       :drpop :dpush 1000 :dmult :fmult :drpush
       :!pair/cdr
:label core-mult-fixed-loop
       :first :!NIL :eq
         :push core-mult-fixed-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-mult-not-number :branch
       :push eval/get-number-value-as-fixed :call
       :drpop :fmult :drpush
       :!pair/cdr
       :push core-mult-fixed-loop :jump

:label core-mult-fixed-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret

:label core-mult-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop
       :!error :swap :ret
)

;; Division function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-div
       :push 0x6964 :push 0 :bufstore
       :push 0x0076 :push 1 :bufstore
       :push core/div
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of dividing
;; the first by all other arguments.
(proc  core/div
       ;; All this is because we keep the first number positive
       :swap
       :first :!NIL :eq
         :push core-div-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-div-not-number :branch
       :first :!number/fixed?
         :push core-div-fixed-first :branch
       :!number/value :drpush
       :!pair/cdr
:label core-div-int-loop
       :first :!NIL :eq
         :push core-div-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-div-not-number :branch
       :first :!number/fixed?
         :push core-div-fixed-start :branch
       :!number/value :drpop :dswap :ddiv :drpush
       :!pair/cdr
       :push core-div-int-loop :jump

:label core-div-int-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-div-fixed-first
       :!number/value :drpush
       :!pair/cdr
       :push core-div-fixed-loop :jump
:label core-div-fixed-start
       :!number/value
       :drpop :dpush 1000 :dmult
       :dswap :fdiv :drpush
       :!pair/cdr
:label core-div-fixed-loop
       :first :!NIL :eq
         :push core-div-fixed-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-div-not-number :branch
       :push eval/get-number-value-as-fixed :call
       :drpop :dswap :fdiv :drpush
       :!pair/cdr
       :push core-div-fixed-loop :jump

:label core-div-fixed-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret

:label core-div-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop
       :!error :swap :ret
)



;; Elementary Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define the cons subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cons
       :push 0x6f63 :push 0 :bufstore
       :push 0x736e :push 1 :bufstore
       :push 0x0061 :push 2 :bufstore
       :push core/cons
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and conses the first onto the second.
;; Leaves the new pair that was created.
(proc  core/cons
       :swap ;; put env on bottom
       :first :!pair/car
       :swap :!pair/cdr :!pair/car
       :push pair/create :call
       :swap ;; put env back on top
       :ret
)

;; Define the car subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-car
       :push 0x6163 :push 0 :bufstore
       :push 0x0061 :push 1 :bufstore
       :push core/car
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and leaves the car of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/car
       :swap ;; put env on bottom
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-car-nil :branch
       :!pair/car
       :swap ;; put env back on top
       :ret
:label core-car-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the cdr subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cdr
       :push 0x6463 :push 0 :bufstore
       :push 0x0061 :push 1 :bufstore
       :push core/cdr
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and leaves the cdr of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/cdr
       :swap ;; put env on bottom
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-cdr-nil :branch
       :!pair/cdr
       :swap ;; put env back on top
       :ret
:label core-cdr-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

)
