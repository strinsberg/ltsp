(lt64-asm-mod

;; Loads all of the data for core functions that use assembled subroutines
(proc  core/load-all
       ;; Elementary
       :push core/make-cons :call
       :push core/make-car :call
       :push core/make-cdr :call
       :push core/make-eq? :call
       :push core/make-atom? :call

       ;; Arithmetic
       :push core/make-add :call
       :push core/make-sub :call
       :push core/make-mult :call
       :push core/make-div :call
       :push core/make-mod :call

       ;; Functional
       :push core/make-map :call
       :push core/make-filter :call
       :push core/make-reduce :call

       ;; Eval, apply, list
       :push core/make-eval :call
       :push core/make-list :call
       :push core/make-apply :call
       :ret
)

;; Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Takes a subroutine label and expects a symbol name in the buffer.
;; Creates all objects necessary to add the subroutine to the the buitin
;; list of definitions.
(proc  core/create
       :push core/create-symbol :call
       :swap :second
       :push core/create-subroutine :call
       :push env/add-define :call
       :ret
)

;; Creates a new symbol from the name in the buffer at :bfp.
;; Takes nothing and leaves the new symbol address.
(proc  core/create-symbol
       :push alloc/new-symbol :call
       :push sym/make :call
       :bfp :second :push sym/set-name :call
       :first :push symlist/add :call
       :ret
)

;; Takes a symbol address and a label off of the stack and creates a
;; subroutine element. Leaves the address of the new element.
(proc  core/create-subroutine
       :push alloc/new-subroutine :call
       :push 0x0600 :second :!sub/set-info
       :swap :second :!sub/set-symbol
       :swap :second :!sub/set-label
       :ret
)
(macro :!sub/info :load-lb)
(macro :!sub/label :push 1 :add :load-lb)
(macro :!sub/symbol :push 2 :add :load-lb)
(macro :!sub/set-info :store-lb)
(macro :!sub/set-label :push 1 :add :store-lb)
(macro :!sub/set-symbol :push 2 :add :store-lb)
(macro :!sub/subroutine? :load-lb :push 8 :sr :push 0x06 :eq)

;; Takes a double word as initial value for the accumulator, the env, the
;; list of arguments, and 2 labels for functions to call to reduce the car of
;; the args list and the accumulator value. The first label is for ints and the
;; second for fixed/int mix.
(proc  core/binary-op-on-list
       :drpush
       :swap
:label core-add-bop-list-loop
       :first :!NIL :eq
         :push core-add-bop-list-end :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-add-bop-list-not-number :branch
       :first :!number/fixed?
         :push core-add-bop-list-fixed-start :branch
       :drpop :push 5 :nth :call :drpush
       :!pair/cdr
       :push core-add-bop-list-loop :jump

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-add-bop-list-fixed-start
       :drpop :dpush 1000 :dmult
       :push 6 :nth :call
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-add-bop-list-end
       :pop :swap :pop :swap :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret
:label core-add-bop-list-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop :swap :pop :swap :pop
       :!ERROR :swap :ret
)

(proc  core/binary-op-on-list-fixed
       :drpush :!pair/cdr
:label core-add-bop-list-fixed-loop
       :first :!NIL :eq
         :push core-add-bop-list-fixed-end :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-add-bop-list-fixed-not-number :branch
       :drpop :push 6 :nth :call :drpush
       :!pair/cdr
       :push core-add-bop-list-fixed-loop :jump

:label core-add-bop-list-fixed-end
       :pop :swap :pop :swap :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret
:label core-add-bop-list-fixed-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop :swap :pop :swap :pop
       :!ERROR :swap :ret
)

;; Elementary Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define the cons subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cons
       :push 0x6f63 :push 0 :bufstore
       :push 0x736e :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/cons
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and conses the first onto the second.
;; Leaves the new pair that was created.
(proc  core/cons
       :swap ;; put env on bottom
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :push core-cons-error :branch
       :first :!pair/car
       :swap :!pair/cdr :!pair/car
       :push pair/create :call
       :swap ;; put env back on top
       :ret
:label core-cons-error
       :push cons-args-error :prnmem-lb
       :swap :pop
       :!ERROR :swap :ret
)

;; Define the car subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-car
       :push 0x6163 :push 0 :bufstore
       :push 0x0072 :push 1 :bufstore
       :push core/car
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and leaves the car of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/car
       :swap ;; put env on bottom
       :first :!NIL :eq
         :push core-car-nil :branch
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-car-nil :branch
       :!pair/car
       :swap ;; put env back on top
       :ret
:label core-car-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the cdr subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cdr
       :push 0x6463 :push 0 :bufstore
       :push 0x0072 :push 1 :bufstore
       :push core/cdr
       :push core/create :call
       :ret
)

;; Takes a list of evaluated arguments and leaves the cdr of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/cdr
       :swap ;; put env on bottom
       :first :!NIL :eq
         :push core-car-nil :branch
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-cdr-nil :branch
       :!pair/cdr
       :swap ;; put env back on top
       :ret
:label core-cdr-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the eq subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-eq?
       :push 0x7165 :push 0 :bufstore
       :push 0x003f :push 1 :bufstore
       :push core/eq?
       :push core/create :call
       :ret
)

(proc  core/eq?
       :swap ;; put env on bottom
       :first :!pair/car
       :second :!pair/cdr :!pair/car
       :push sym/both-symbols? :call
         :push core-eq-symbols :branch
       :push number/both-fixed? :call
         :push core-eq-fixed :branch
       :push number/both-numbers? :call
         :push core-eq-numbers :branch
       :pop :pop :pop
       :!F :swap :ret

:label core-eq-symbols
       :eq :push sym/bool-to-T-F :call
       :swap :pop
       :swap :ret
:label core-eq-fixed
       :!number/value
       :rot :!number/value
       :deq :!->word :push sym/bool-to-T-F :call
       :swap :pop
       :swap :ret
:label core-eq-numbers
       :push number/get-value-as-int :call
       :rot
       :push number/get-value-as-int :call
       :deq :!->word :push sym/bool-to-T-F :call
       :swap :pop
       :swap :ret
)

;; Define the atom? subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-atom?
       :push 0x7461 :push 0 :bufstore
       :push 0x6d6f :push 1 :bufstore
       :push 0x003f :push 2 :bufstore
       :push core/atom?
       :push core/create :call
       :ret
)

;; Takes a list of evalled arguments and checks to see if the car is an atom.
;; Leaves T if it is an atom, otherwise F.
(proc  core/atom?
       :swap ;; put env on bottom
       :!pair/car :push eval/atom? :call
         :push core-atom?-true :branch
       :!F :swap :ret
:label core-atom?-true
       :!T :swap :ret
)

;; Arithmetic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates the add function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-add
       :push 0x6461 :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/add
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of adding the
;; arguments together.
(proc  core/add
       :push core/add-fixed-func
       :push core/add-int-func
       :dswap
       :dpush 0  ;; setup initial value
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/add-int-func
       :rot :!number/value :dadd
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/add-fixed-func
       :rot :push number/get-value-as-fixed :call :dadd
       :ret
)

;; Creates the mult function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-mult
       :push 0x756d :push 0 :bufstore
       :push 0x746c :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/mult
       :push core/create :call
       :ret
)

;; arguments together.
(proc  core/mult
       :push core/mult-fixed-func
       :push core/mult-int-func
       :dswap
       :dpush 1  ;; setup initial value
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/mult-int-func
       :rot :!number/value :dmult
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/mult-fixed-func
       :rot :push number/get-value-as-fixed :call :fmult
       :ret
)

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-sub
       :push 0x7573 :push 0 :bufstore
       :push 0x0062 :push 1 :bufstore
       :push core/sub
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of subtracting
;; the arguments together.
(proc  core/sub
       :push core/sub-fixed-func
       :push core/sub-int-func
       :dswap
       ;; Setup first number
       :swap
       :first :!NIL :eq
         :push core-sub-first-arg-zero :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-sub-first-arg-zero :branch
       :first :!number/fixed?
         :push core-sub-fixed-first :branch
       :!number/value
       :dswap :!pair/cdr :swap :dswap
       ;; call accumulator
       :push core/binary-op-on-list :call
       :ret

:label core-sub-fixed-first
       :!number/value
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-sub-first-arg-zero
       :swap :dpush 0
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/sub-int-func
       :rot :!number/value :dsub
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/sub-fixed-func
       :rot :push number/get-value-as-fixed :call :dsub
       :ret
)

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-div
       :push 0x6964 :push 0 :bufstore
       :push 0x0076 :push 1 :bufstore
       :push core/div
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of dividing the
;; arguments together.
(proc  core/div
       :push core/div-fixed-func
       :push core/div-int-func
       :dswap
       ;; Setup first number
       :swap
       :first :!NIL :eq
         :push core-div-first-arg-zero :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-div-first-arg-zero :branch
       :first :!number/fixed?
         :push core-div-fixed-first :branch
       :!number/value
       :dswap :!pair/cdr :swap :dswap
       ;; call accumulator
       :push core/binary-op-on-list :call
       :ret

:label core-div-fixed-first
       :!number/value
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-div-first-arg-zero
       :swap :dpush 0
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/div-int-func
       :rot :!number/value :ddiv
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/div-fixed-func
       :rot :push number/get-value-as-fixed :call :fdiv
       :ret
)

;; Creates mod function that takes the modulo of its first argument by its
;; second.
(proc  core/make-mod
       :push 0x6f6d :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/mod
       :push core/create :call
       :ret
)

(proc  core/mod
       :second :!NIL :eq
         :!third :!pair/cdr :!NIL :eq
         :or :push core-mod-args-error :branch
       :second :!pair/car
       :!third :!pair/cdr :!pair/car
       :push number/both-numbers? :call :!not 
         :push core-mod-not-numbers :branch
       :swap :push number/get-value-as-int :call
       :rot :push number/get-value-as-int :call
       :dmod :push number/create-int :call
       :rot :pop :swap :ret

:label core-mod-args-error
       :push num-args-error-2 :prnmem-lb
       :push str-mod :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
:label core-mod-not-numbers
       :push args-number-error :prnmem-lb
       :push str-mod :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
)

;; Map, filter, reduce ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates a map symbol for a function that maps a function to a list of
;; arguments.
(proc  core/make-map
       :push 0x616d :push 0 :bufstore
       :push 0x0070 :push 1 :bufstore
       :push core/map
       :push core/create :call
       :ret
)

;; Expects an env and an evaluated argument list that starts with a subroutine
;; or a procedure and then a list of arguments to apply that procedure to.
;; Leaves the env and the new list.
(proc  core/map
       :push 0 :swap :rot
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :push core-map-args-error :branch
       :first :!pair/car ;; proc
       :swap :!pair/cdr :!pair/car ;; list
       :rot
:label core-map-apply-loop
       :second :!NIL :eq
         :push core-map-end :branch
       :second :!pair/car :!NIL
       :push pair/create :call
       :!fourth :swap :rot
       :push eval/apply-sub-or-proc :call
       :dswap :!pair/cdr :rot
       :push core-map-apply-loop :jump

:label core-map-end
       :rot :pop :rpush
       :push pair/create-list :call
       :rpop :ret
:label core-map-args-error
       :push map-args-error :prnmem-lb
       :pop :!ERROR :swap :ret
)

;; Creates a filter symbol for a function that filters a list of
;; arguments using a predicate.
(proc  core/make-filter
       :push 0x6966 :push 0 :bufstore
       :push 0x746c :push 1 :bufstore
       :push 0x7265 :push 2 :bufstore
       :push 0x0000 :push 3 :bufstore
       :push core/filter
       :push core/create :call
       :ret
)

;; Expects an env and an evaluated argument list that starts with a subroutine
;; or a procedure and then a list of arguments to filter with that procedure.
;; Leaves the env and the new list.
(proc  core/filter
       :push 0 :swap :rot
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :push core-filter-args-error :branch
       :first :!pair/car ;; proc
       :swap :!pair/cdr :!pair/car ;; list
       :rot
:label core-filter-apply-loop
       :second :push debug-form :call
       :second :!NIL :eq
         :push core-filter-end :branch
       :second :!pair/car :!NIL
       :push pair/create :call
       :!fourth :swap :rot
       :push eval/apply-sub-or-proc :call
       :second :push sym/falsy? :call
         :push core-filter-apply-discard :branch
       :swap :pop ;; remove bool
       :second :!pair/car :swap
       :dswap :!pair/cdr :rot
       :push core-filter-apply-loop :jump
:label core-filter-apply-discard
       :swap :pop :swap :!pair/cdr :swap
       :push core-filter-apply-loop :jump

:label core-filter-end
       :rot :pop :rpush
       :push pair/create-list :call
       :rpop :ret
:label core-filter-args-error
       :push filter-args-error :prnmem-lb
       :pop :!ERROR :swap :ret
)

;; Creates a reduce symbol for a function that uses a sub/proc to reduce a list
;; of arguments to a single value.
(proc  core/make-reduce
       :push 0x6572 :push 0 :bufstore
       :push 0x7564 :push 1 :bufstore
       :push 0x6563 :push 2 :bufstore
       :push 0x0000 :push 3 :bufstore
       :push core/reduce
       :push core/create :call
       :ret
)

;; Expects an env and an evaluated argument list that starts with a subroutine
;; or a procedure and then an initial value followed by a list of arguments to
;; reduce with the sub/proc and the initial value.
;; Leaves the env and the reduction.
(proc  core/reduce
       :swap
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :second :!pair/cdr :!pair/cdr :!NIL :eq
         :or :push core-reduce-args-error :branch
       :first :!pair/car ;; proc
       :second :!pair/cdr :!pair/car ;; initial
       :rot :!pair/cdr :!pair/cdr :!pair/car ;; list
       :dswap :rot :rot
:label core-reduce-apply-loop
       :second :!NIL :eq
         :push core-reduce-end :branch
       :push 0 :!fifth :!fourth :!pair/car :!NIL
       :push pair/create-list :call
       :!fourth :swap :rot
       :push eval/apply-sub-or-proc :call
       :rpush :rpush :!pair/cdr
       :rot :pop :rpop :rot :rot :rpop
       :push core-reduce-apply-loop :jump

:label core-reduce-end
       :swap :pop :swap :pop :ret
:label core-reduce-args-error
       :push reduce-args-error :prnmem-lb
       :pop :!ERROR :swap :ret
)


;; Eval, Apply, List ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates a  symbol for a function that evaluates a form.
(proc  core/make-eval
       :push 0x7665 :push 0 :bufstore
       :push 0x6c61 :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/eval
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments. Leaves the env and the evaluation
;; of the first argument.
(proc  core/eval
       :second :!NIL :eq
         :push core-eval-args-error :branch
       :swap :!pair/car :swap
       :push eval/form :call
       :ret
:label core-eval-args-error
       :push num-args-error-1 :prnmem-lb
       :push str-eval :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
)

;; Creates a  symbol for a function that creates a list from its arguments.
(proc  core/make-list
       :push 0x696c :push 0 :bufstore
       :push 0x7473 :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/list
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments. Leaves the env and the list of
;; arguments.
(proc  core/list
       ;; Does not have to do anything because eval/list already
       ;; created a list of the arguments.
       :ret
)

;; Creates a symbol for a function that applies sub/proc to a list as if the
;; list elements were arguments to the function. I.e. (apply add (2 3 4)) is
;; equivilent to (add 2 3 4).
(proc  core/make-apply
       :push 0x7061 :push 0 :bufstore
       :push 0x6c70 :push 1 :bufstore
       :push 0x0079 :push 2 :bufstore
       :push core/apply
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments. The first argument is a procedure
;; and the second argument is the list of arguments to the procedure. Leaves
;; the env and the application of the procedure to its list of arguments.
(proc  core/apply
       :second :!NIL :eq
         :!third :!pair/cdr :!NIL :eq
         :or :push core-apply-args-error :branch
       :second :!pair/car
       :rot :!pair/cdr :!pair/car
       :rot
       :push eval/apply-sub-or-proc :call
       :ret

:label core-apply-args-error
       :push num-args-error-2 :prnmem-lb
       :push str-apply :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
)

)
