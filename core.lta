(lt64-asm-mod

;; Loads all of the data for core functions that use assembled subroutines
(proc  core/load-all
       :push core/make-add :call
       :push core/make-sub :call
       :ret
)

;; Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates a new symbol from the name in the buffer at :bfp.
;; Takes nothing and leaves the new symbol address.
(proc  core/create-symbol
       :push alloc/new-symbol :call
       :push sym/make :call
       :bfp :second :push sym/set-name :call
       :first :push symlist/add :call
       :ret
)

;; Takes a label off of the stack and creates a subroutine element.
;; Leaves the address of the new element.
(proc  core/create-subroutine
       :push alloc/new-subroutine :call
       :push 0x0600 :second :!sub/set-info
       :swap :second :!sub/set-label
       :ret
)
(macro :!sub/info :load-lb)
(macro :!sub/label :push 1 :add :load-lb)
(macro :!sub/set-info :store-lb)
(macro :!sub/set-label :push 1 :add :store-lb)
(macro :!sub/subroutine? :load-lb :push 8 :sr :push 0x06 :eq)


;; Addition function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates the add function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-add
       :push 0x6461 :push 0 :bufstore :push 0x0064 :push 1 :bufstore
       :push core/create-symbol :call
       :push core/add :push core/create-subroutine :call
       :push env/add-define :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of adding the
;; arguments together.
(proc  core/add
       :dpush 0 :drpush
       :swap
:label core-add-int-loop
       :first :!NIL :eq
         :push core-add-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-add-not-number :branch
       :first :!number/fixed?
         :push core-add-fixed-start :branch
       :!number/value :drpop :dadd :drpush
       :!pair/cdr
       :push core-add-int-loop :jump

:label core-add-int-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-add-fixed-start
       :!number/value
       :drpop :dpush 1000 :dmult :dadd :drpush
       :!pair/cdr
:label core-add-fixed-loop
       :first :!NIL :eq
         :push core-add-fixed-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-add-not-number :branch
       :push eval/get-number-value-as-fixed :call
       :drpop :dadd :drpush
       :!pair/cdr
       :push core-add-fixed-loop :jump

:label core-add-fixed-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret

:label core-add-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop
       :!error :swap :ret
)

;; Subtraction function ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-sub
       :push 0x7573 :push 0 :bufstore :push 0x0062 :push 1 :bufstore
       :push core/create-symbol :call
       :push core/sub :push core/create-subroutine :call
       :push env/add-define :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of subtracting
;; all arguments from the first.
(proc  core/sub
       ;; All this is because we keep the first number positive
       :swap
       :first :!NIL :eq
         :push core-sub-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-sub-not-number :branch
       :first :!number/fixed?
         :push core-sub-fixed-first :branch
       :!number/value :drpush
       :!pair/cdr
:label core-sub-int-loop
       :first :!NIL :eq
         :push core-sub-int-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-sub-not-number :branch
       :first :!number/fixed?
         :push core-sub-fixed-start :branch
       :!number/value :drpop :dswap :dsub :drpush
       :!pair/cdr
       :push core-sub-int-loop :jump

:label core-sub-int-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-sub-fixed-first
       :!number/value :drpush
       :!pair/cdr
       :push core-sub-fixed-loop :jump
:label core-sub-fixed-start
       :!number/value
       :drpop :dpush 1000 :dmult
       :dswap :dsub :drpush
       :!pair/cdr
:label core-sub-fixed-loop
       :first :!NIL :eq
         :push core-sub-fixed-end :branch
       :first :!pair/car
       :!third :push eval/form :call
       :pop ;; the copied env
       :first :push number/number? :call :!not
         :push core-sub-not-number :branch
       :push eval/get-number-value-as-fixed :call
       :drpop :dswap :dsub :drpush
       :!pair/cdr
       :push core-sub-fixed-loop :jump

:label core-sub-fixed-end
       :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret

:label core-sub-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop
       :!error :swap :ret
)


;; Takes an integer value (double word) and stores it in the appropriate memory.
;; Leaves the address of the created memory.
(proc  core/create-int
       :push alloc/new-pair :call
       :push number/make-int :call
       :ret
)

)
