(lt64-asm-mod

;; Loads all of the data for core functions that use assembled subroutines
(proc  core/load-all
       ;; Elementary
       :push core/make-cons :call
       :push core/make-car :call
       :push core/make-cdr :call
       :push core/make-eq? :call
       :push core/make-atom? :call

       ;; Arithmetic
       :push core/make-add :call
       :push core/make-sub :call
       :push core/make-mult :call
       :push core/make-div :call
       :ret
)

;; Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Takes a subroutine label and expects a symbol name in the buffer.
;; Creates all objects necessary to add the subroutine to the the buitin
;; list of definitions.
(proc  core/create
       :push core/create-symbol :call
       :swap :second
       :push core/create-subroutine :call
       :push env/add-define :call
       :ret
)

;; Creates a new symbol from the name in the buffer at :bfp.
;; Takes nothing and leaves the new symbol address.
(proc  core/create-symbol
       :push alloc/new-symbol :call
       :push sym/make :call
       :bfp :second :push sym/set-name :call
       :first :push symlist/add :call
       :ret
)

;; Takes a symbol address and a label off of the stack and creates a
;; subroutine element. Leaves the address of the new element.
(proc  core/create-subroutine
       :push alloc/new-subroutine :call
       :push 0x0600 :second :!sub/set-info
       :swap :second :!sub/set-symbol
       :swap :second :!sub/set-label
       :ret
)
(macro :!sub/info :load-lb)
(macro :!sub/label :push 1 :add :load-lb)
(macro :!sub/symbol :push 2 :add :load-lb)
(macro :!sub/set-info :store-lb)
(macro :!sub/set-label :push 1 :add :store-lb)
(macro :!sub/set-symbol :push 2 :add :store-lb)
(macro :!sub/subroutine? :load-lb :push 8 :sr :push 0x06 :eq)

;; Takes a double word as initial value for the accumulator, the env, the
;; list of arguments, and 2 labels for functions to call to reduce the car of
;; the args list and the accumulator value. The first label is for ints and the
;; second for fixed/int mix.
(proc  core/binary-op-on-list
       :drpush
       :swap
:label core-add-bop-list-loop
       :first :!NIL :eq
         :push core-add-bop-list-end :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-add-bop-list-not-number :branch
       :first :!number/fixed?
         :push core-add-bop-list-fixed-start :branch
       :drpop :push 5 :nth :call :drpush
       :!pair/cdr
       :push core-add-bop-list-loop :jump

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-add-bop-list-fixed-start
       :drpop :dpush 1000 :dmult
       :push 6 :nth :call
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-add-bop-list-end
       :pop :swap :pop :swap :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret
:label core-add-bop-list-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop :swap :pop :swap :pop
       :!error :swap :ret
)

(proc  core/binary-op-on-list-fixed
       :drpush :!pair/cdr
:label core-add-bop-list-fixed-loop
       :first :!NIL :eq
         :push core-add-bop-list-fixed-end :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-add-bop-list-fixed-not-number :branch
       :drpop :push 6 :nth :call :drpush
       :!pair/cdr
       :push core-add-bop-list-fixed-loop :jump

:label core-add-bop-list-fixed-end
       :pop :swap :pop :swap :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret
:label core-add-bop-list-fixed-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop :swap :pop :swap :pop
       :!error :swap :ret
)

;; Elementary Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define the cons subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cons
       :push 0x6f63 :push 0 :bufstore
       :push 0x736e :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/cons
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and conses the first onto the second.
;; Leaves the new pair that was created.
(proc  core/cons
       :push eval/list :call  ;; while it is not on the outside
       :swap ;; put env on bottom
       :first :!pair/car
       :swap :!pair/cdr :!pair/car
       :push pair/create :call
       :swap ;; put env back on top
       :ret
)

;; Define the car subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-car
       :push 0x6163 :push 0 :bufstore
       :push 0x0072 :push 1 :bufstore
       :push core/car
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and leaves the car of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/car
       :push eval/list :call  ;; while it is not on the outside
       :swap ;; put env on bottom
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-car-nil :branch
       :!pair/car
       :swap ;; put env back on top
       :ret
:label core-car-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the cdr subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cdr
       :push 0x6463 :push 0 :bufstore
       :push 0x0072 :push 1 :bufstore
       :push core/cdr
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and leaves the cdr of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/cdr
       :push eval/list :call  ;; while it is not on the outside
       :swap ;; put env on bottom
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-cdr-nil :branch
       :!pair/cdr
       :swap ;; put env back on top
       :ret
:label core-cdr-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the eq subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-eq?
       :push 0x7165 :push 0 :bufstore
       :push 0x003f :push 1 :bufstore
       :push core/eq?
       :push core/create :call
       :ret
)

(proc  core/eq?
       :push eval/list :call  ;; while it is not on the outside
       :swap ;; put env on bottom
       :first :!pair/car
       :second :!pair/cdr :!pair/car
       :push eval/both-symbols? :call
         :push core-eq-symbols :branch
       :push eval/both-fixed? :call
         :push core-eq-fixed :branch
       :push eval/both-numbers? :call
         :push core-eq-numbers :branch
       :pop :pop :pop
       :!F :swap :ret

:label core-eq-symbols
       :eq :push eval/bool-to-T-F :call
       :swap :pop
       :swap :ret
:label core-eq-fixed
       :!number/value
       :rot :!number/value
       :deq :!->word :push eval/bool-to-T-F :call
       :swap :pop
       :swap :ret
:label core-eq-numbers
       :push eval/get-number-value-as-int :call
       :rot
       :push eval/get-number-value-as-int :call
       :deq :!->word :push eval/bool-to-T-F :call
       :swap :pop
       :swap :ret
)

;; Define the atom? subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-atom?
       :push 0x7461 :push 0 :bufstore
       :push 0x6d6f :push 1 :bufstore
       :push 0x003f :push 2 :bufstore
       :push core/atom?
       :push core/create :call
       :ret
)

;; Takes a list of evalled arguments and checks to see if the car is an atom.
;; Leaves T if it is an atom, otherwise F.
(proc  core/atom?
       :push eval/list :call  ;; while it is not on the outside
       :swap ;; put env on bottom
       :!pair/car :push eval/atom? :call
         :push core-atom?-true :branch
       :!F :swap :ret
:label core-atom?-true
       :!T :swap :ret
)

;; Arithmetic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates the add function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-add
       :push 0x6461 :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/add
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of adding the
;; arguments together.
(proc  core/add
       :push core/add-fixed-func
       :push core/add-int-func
       :dswap
       :push eval/list :call  ;; while it is not on the outside
       :dpush 0  ;; setup initial value
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/add-int-func
       :rot :!number/value :dadd
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/add-fixed-func
       :rot :push eval/get-number-value-as-fixed :call :dadd
       :ret
)

;; Creates the mult function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-mult
       :push 0x756d :push 0 :bufstore
       :push 0x746c :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/mult
       :push core/create :call
       :ret
)

;; arguments together.
(proc  core/mult
       :push core/mult-fixed-func
       :push core/mult-int-func
       :dswap
       :push eval/list :call  ;; while it is not on the outside
       :dpush 1  ;; setup initial value
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/mult-int-func
       :rot :!number/value :dmult
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/mult-fixed-func
       :rot :push eval/get-number-value-as-fixed :call :fmult
       :ret
)

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-sub
       :push 0x7573 :push 0 :bufstore
       :push 0x0062 :push 1 :bufstore
       :push core/sub
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of subtracting
;; the arguments together.
(proc  core/sub
       :push core/sub-fixed-func
       :push core/sub-int-func
       :dswap
       :push eval/list :call  ;; while it is not on the outside
       ;; Setup first number
       :swap
       :first :!NIL :eq
         :push core-sub-first-arg-zero :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-sub-first-arg-zero :branch
       :first :!number/fixed?
         :push core-sub-fixed-first :branch
       :!number/value
       :dswap :!pair/cdr :swap :dswap
       ;; call accumulator
       :push core/binary-op-on-list :call
       :ret

:label core-sub-fixed-first
       :!number/value
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-sub-first-arg-zero
       :dpush 0
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/sub-int-func
       :rot :!number/value :dsub
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/sub-fixed-func
       :rot :push eval/get-number-value-as-fixed :call :dsub
       :ret
)

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-div
       :push 0x6964 :push 0 :bufstore
       :push 0x0076 :push 1 :bufstore
       :push core/div
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of dividing the
;; arguments together.
(proc  core/div
       :push core/div-fixed-func
       :push core/div-int-func
       :dswap
       :push eval/list :call  ;; while it is not on the outside
       ;; Setup first number
       :swap
       :first :!NIL :eq
         :push core-div-first-arg-zero :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-div-first-arg-zero :branch
       :first :!number/fixed?
         :push core-div-fixed-first :branch
       :!number/value
       :dswap :!pair/cdr :swap :dswap
       ;; call accumulator
       :push core/binary-op-on-list :call
       :ret

:label core-div-fixed-first
       :!number/value
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-div-first-arg-zero
       :dpush 0
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/div-int-func
       :rot :!number/value :ddiv
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/div-fixed-func
       :rot :push eval/get-number-value-as-fixed :call :fdiv
       :ret
)

)
