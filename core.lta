(lt64-asm-mod

;; Loads all of the data for core functions that use assembled subroutines
(proc  core/load-all
       ;; Elementary
       :push core/make-cons :call
       :push core/make-car :call
       :push core/make-cdr :call
       :push core/make-eq? :call
       :push core/make-atom? :call

       ;; Arithmetic
       :push core/make-add :call
       :push core/make-sub :call
       :push core/make-mult :call
       :push core/make-div :call
       :push core/make-mod :call

       ;; Relational
       :push core/make-less :call
       :push core/make-greater :call

       ;; Boolean
       :push core/make-and :call
       :push core/make-or :call
       :push core/make-not :call

       ;; Functional
       :push core/make-map :call
       :push core/make-filter :call
       :push core/make-reduce :call
       :push core/make-do :call  ;; opposite of functional

       ;; Eval, apply, list, memory
       :push core/make-eval :call
       :push core/make-list :call
       :push core/make-apply :call
       :push core/make-load :call
       :push core/make-dump :call

       ;; I/0
       :push core/make-read-num :call
       :push core/make-prn :call
       :push core/make-prnln :call
       :push core/make-print :call
       :push core/make-println :call

       :ret
)

;; Helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Takes a subroutine label and expects a symbol name in the buffer.
;; Creates all objects necessary to add the subroutine to the the buitin
;; list of definitions.
(proc  core/create
       :push core/create-symbol :call
       :swap :second
       :push core/create-subroutine :call
       :push env/add-define :call
       :ret
)

;; Creates a new symbol from the name in the buffer at :bfp.
;; Takes nothing and leaves the new symbol address.
(proc  core/create-symbol
       :push alloc/new-symbol :call
       :push sym/make :call
       :bfp :second :push sym/set-name :call
       :first :push symlist/add :call
       :ret
)

;; Takes a symbol address and a label off of the stack and creates a
;; subroutine element. Leaves the address of the new element.
(proc  core/create-subroutine
       :push alloc/new-subroutine :call
       :push 0x0600 :second :!sub/set-info
       :swap :second :!sub/set-symbol
       :swap :second :!sub/set-label
       :ret
)
(macro :!sub/info :load-lb)
(macro :!sub/label :push 1 :add :load-lb)
(macro :!sub/symbol :push 2 :add :load-lb)
(macro :!sub/set-info :store-lb)
(macro :!sub/set-label :push 1 :add :store-lb)
(macro :!sub/set-symbol :push 2 :add :store-lb)
(macro :!sub/subroutine? :load-lb :push 8 :sr :push 0x06 :eq)

;; Takes a double word as initial value for the accumulator, the env, the
;; list of arguments, and 2 labels for functions to call to reduce the car of
;; the args list and the accumulator value. The first label is for ints and the
;; second for fixed/int mix.
(proc  core/binary-op-on-list
       :drpush
       :swap
:label core-add-bop-list-loop
       :first :!NIL :eq
         :push core-add-bop-list-end :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-add-bop-list-not-number :branch
       :first :!number/fixed?
         :push core-add-bop-list-fixed-start :branch
       :drpop :push 5 :nth :call :drpush
       :!pair/cdr
       :push core-add-bop-list-loop :jump

;; If a single value in the list is a fixed point number then
;; all numbers must be treated as such
:label core-add-bop-list-fixed-start
       :drpop :dpush 1000 :dmult
       :push 6 :nth :call
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-add-bop-list-end
       :pop :swap :pop :swap :pop :drpop
       :push alloc/new-pair :call
       :push number/make-int :call
       :swap :ret
:label core-add-bop-list-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop :swap :pop :swap :pop
       :!ERROR :swap :ret
)

(proc  core/binary-op-on-list-fixed
       :drpush :!pair/cdr
:label core-add-bop-list-fixed-loop
       :first :!NIL :eq
         :push core-add-bop-list-fixed-end :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-add-bop-list-fixed-not-number :branch
       :drpop :push 6 :nth :call :drpush
       :!pair/cdr
       :push core-add-bop-list-fixed-loop :jump

:label core-add-bop-list-fixed-end
       :pop :swap :pop :swap :pop :drpop
       :push alloc/new-pair :call
       :push number/make-fixed :call
       :swap :ret
:label core-add-bop-list-fixed-not-number
       :drpop :dpop
       :push not-a-number-error :prnmem-lb
       :push debug-form :call
       :pop :swap :pop :swap :pop
       :!ERROR :swap :ret
)

;; Elementary Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define the cons subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cons
       :push 0x6f63 :push 0 :bufstore
       :push 0x736e :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/cons
       :push core/create :call
       :ret
)

;; Takes an env and list of evaluated arguments and conses the first onto the
;; second. Leaves the new pair that was created.
(proc  core/cons
       :swap ;; put env on bottom
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :push core-cons-error :branch
       :first :!pair/car
       :swap :!pair/cdr :!pair/car
       :push pair/create :call
       :swap ;; put env back on top
       :ret
:label core-cons-error
       :push cons-args-error :prnmem-lb
       :swap :pop
       :!ERROR :swap :ret
)

;; Define the car subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-car
       :push 0x6163 :push 0 :bufstore
       :push 0x0072 :push 1 :bufstore
       :push core/car
       :push core/create :call
       :ret
)

;; Currently takes the ENV on top
;; Takes a list of evaluated arguments and leaves the car of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/car
       :swap ;; put env on bottom
       :first :!NIL :eq
         :push core-car-nil :branch
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-car-nil :branch
       :!pair/car
       :swap ;; put env back on top
       :ret
:label core-car-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the cdr subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-cdr
       :push 0x6463 :push 0 :bufstore
       :push 0x0072 :push 1 :bufstore
       :push core/cdr
       :push core/create :call
       :ret
)

;; Takes a list of evaluated arguments and leaves the cdr of the first
;; argument if it is a pair, otherwise leaves NIL.
(proc  core/cdr
       :swap ;; put env on bottom
       :first :!NIL :eq
         :push core-car-nil :branch
       :!pair/car
       :first :!pair/pair?
         :second :!pair/dotted?
         :or :!not
         :push core-cdr-nil :branch
       :!pair/cdr
       :swap ;; put env back on top
       :ret
:label core-cdr-nil
       :pop :!NIL
       :swap ;; put env back on top
       :ret
)

;; Define the eq subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-eq?
       :push 0x7165 :push 0 :bufstore
       :push 0x003f :push 1 :bufstore
       :push core/eq?
       :push core/create :call
       :ret
)

(proc  core/eq?
       :swap ;; put env on bottom
       :first :!pair/car
       :second :!pair/cdr :!pair/car
       :push sym/both-symbols? :call
         :push core-eq-symbols :branch
       :push number/both-fixed? :call
         :push core-eq-fixed :branch
       :push number/both-numbers? :call
         :push core-eq-numbers :branch
       :pop :pop :pop
       :!F :swap :ret

:label core-eq-symbols
       :eq :push sym/bool-to-T-F :call
       :swap :pop
       :swap :ret
:label core-eq-fixed
       :!number/value
       :rot :!number/value
       :deq :!->word :push sym/bool-to-T-F :call
       :swap :pop
       :swap :ret
:label core-eq-numbers
       :push number/get-value-as-int :call
       :rot
       :push number/get-value-as-int :call
       :deq :!->word :push sym/bool-to-T-F :call
       :swap :pop
       :swap :ret
)

;; Define the atom? subroutine. Takes nothing, Leaves Nothing.
(proc  core/make-atom?
       :push 0x7461 :push 0 :bufstore
       :push 0x6d6f :push 1 :bufstore
       :push 0x003f :push 2 :bufstore
       :push core/atom?
       :push core/create :call
       :ret
)

;; Takes a list of evalled arguments and checks to see if the car is an atom.
;; Leaves T if it is an atom, otherwise F.
(proc  core/atom?
       :swap ;; put env on bottom
       :!pair/car :push eval/atom? :call
         :push core-atom?-true :branch
       :!F :swap :ret
:label core-atom?-true
       :!T :swap :ret
)

;; Arithmetic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates the add function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-add
       :push 0x6461 :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/add
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of adding the
;; arguments together.
(proc  core/add
       :push core/add-fixed-func
       :push core/add-int-func
       :dswap
       :dpush 0  ;; setup initial value
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/add-int-func
       :rot :!number/value :dadd
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/add-fixed-func
       :rot :push number/get-value-as-fixed :call :dadd
       :ret
)

;; Creates the mult function symbol, subroutine, and adds them as a define
;; in the builtin environment.
(proc  core/make-mult
       :push 0x756d :push 0 :bufstore
       :push 0x746c :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/mult
       :push core/create :call
       :ret
)

;; arguments together.
(proc  core/mult
       :push core/mult-fixed-func
       :push core/mult-int-func
       :dswap
       :dpush 1  ;; setup initial value
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/mult-int-func
       :rot :!number/value :dmult
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/mult-fixed-func
       :rot :push number/get-value-as-fixed :call :fmult
       :ret
)

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-sub
       :push 0x7573 :push 0 :bufstore
       :push 0x0062 :push 1 :bufstore
       :push core/sub
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of subtracting
;; the arguments together.
(proc  core/sub
       :push core/sub-fixed-func
       :push core/sub-int-func
       :dswap
       ;; Setup first number
       :swap
       :first :!NIL :eq
         :push core-sub-first-arg-zero :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-sub-first-arg-zero :branch
       :first :!number/fixed?
         :push core-sub-fixed-first :branch
       :!number/value
       :dswap :!pair/cdr :swap :dswap
       ;; call accumulator
       :push core/binary-op-on-list :call
       :ret

:label core-sub-fixed-first
       :!number/value
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-sub-first-arg-zero
       :swap :dpush 0
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/sub-int-func
       :rot :!number/value :dsub
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/sub-fixed-func
       :rot :push number/get-value-as-fixed :call :dsub
       :ret
)

;; Creates sub symbol, subroutine, and adds them as a builtin env-item.
(proc  core/make-div
       :push 0x6964 :push 0 :bufstore
       :push 0x0076 :push 1 :bufstore
       :push core/div
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and returns the result of dividing the
;; arguments together.
(proc  core/div
       :push core/div-fixed-func
       :push core/div-int-func
       :dswap
       ;; Setup first number
       :swap
       :first :!NIL :eq
         :push core-div-first-arg-zero :branch
       :first :!pair/car
       :first :push number/number? :call :!not
         :push core-div-first-arg-zero :branch
       :first :!number/fixed?
         :push core-div-fixed-first :branch
       :!number/value
       :dswap :!pair/cdr :swap :dswap
       ;; call accumulator
       :push core/binary-op-on-list :call
       :ret

:label core-div-fixed-first
       :!number/value
       :push core/binary-op-on-list-fixed :call
       :ret
:label core-div-first-arg-zero
       :swap :dpush 0
       :push core/binary-op-on-list :call
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Leaves the double word result.
(proc  core/div-int-func
       :rot :!number/value :ddiv
       :ret
)

;; Takes a double word and the address of a number on the stack.
;; Treats the number as a fixed point number, so if it is an int it will be
;; converted to a fixed point number.
;; Leaves the double word result.
(proc  core/div-fixed-func
       :rot :push number/get-value-as-fixed :call :fdiv
       :ret
)

;; Creates mod function that takes the modulo of its first argument by its
;; second.
(proc  core/make-mod
       :push 0x6f6d :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/mod
       :push core/create :call
       :ret
)

(proc  core/mod
       :second :!NIL :eq
         :!third :!pair/cdr :!NIL :eq
         :or :push core-mod-args-error :branch
       :second :!pair/car
       :!third :!pair/cdr :!pair/car
       :push number/both-numbers? :call :!not 
         :push core-mod-not-numbers :branch
       :swap :push number/get-value-as-int :call
       :rot :push number/get-value-as-int :call
       :dmod :push number/create-int :call
       :rot :pop :swap :ret

:label core-mod-args-error
       :push num-args-error-2 :prnmem-lb
       :push str-mod :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
:label core-mod-not-numbers
       :push args-number-error :prnmem-lb
       :push str-mod :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
)

;; Relational ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates less than function that decides if the first argument is less than
;; its second.
(proc  core/make-less
       :push 0x656c :push 0 :bufstore
       :push 0x7373 :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/less
       :push core/create :call
       :ret
)

(proc  core/less
       :second :!NIL :eq
         :!third :!pair/cdr :!NIL :eq
         :or :push core-less-args-error :branch
       :second :!pair/car
       :!third :!pair/cdr :!pair/car
       :push number/both-numbers? :call :!not 
         :push core-less-not-numbers :branch
       :push number/both-ints? :call :!not 
         :push core-less-fixed-numbers :branch
       :swap :!number/value :rot :!number/value
       :push core-less-end :jump

:label core-less-fixed-numbers
       :swap :push number/get-value-as-fixed :call
       :rot :push number/get-value-as-fixed :call
:label core-less-end
       :dlt :!->word :push core/bool-to-T-F :call
       :rot :pop :swap :ret

:label core-less-args-error
       :push num-args-error-2 :prnmem-lb
       :push str-less :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
:label core-less-not-numbers
       :push args-number-error :prnmem-lb
       :push str-less :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
)

;; Creates greater than function that decides if the first argument is greater
;; than its second.
(proc  core/make-greater
       :push 0x7267 :push 0 :bufstore
       :push 0x6165 :push 1 :bufstore
       :push 0x6574 :push 2 :bufstore
       :push 0x0072 :push 3 :bufstore
       :push core/greater
       :push core/create :call
       :ret
)

(proc  core/greater
       :second :!NIL :eq
         :!third :!pair/cdr :!NIL :eq
         :or :push core-greater-args-error :branch
       :second :!pair/car
       :!third :!pair/cdr :!pair/car
       :push number/both-numbers? :call :!not 
         :push core-greater-not-numbers :branch
       :push number/both-ints? :call :!not 
         :push core-greater-fixed-numbers :branch
       :swap :!number/value :rot :!number/value
       :push core-greater-end :jump

:label core-greater-fixed-numbers
       :swap :push number/get-value-as-fixed :call
       :rot :push number/get-value-as-fixed :call
:label core-greater-end
       :dgt :!->word :push core/bool-to-T-F :call
       :rot :pop :swap :ret

:label core-greater-args-error
       :push num-args-error-2 :prnmem-lb
       :push str-greater :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
:label core-greater-not-numbers
       :push args-number-error :prnmem-lb
       :push str-greater :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
       :ret
)

;; Boolean ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates an and function that will leave F if any list element is falsy,
;; otherwise T.
(proc  core/make-and
       :push 0x6e61 :push 0 :bufstore
       :push 0x0064 :push 1 :bufstore
       :push core/and
       :push core/create :call
       :ret
)

(proc  core/and
:label core-and-loop
       :second :!NIL :eq
         :push core-and-loop-true :branch
       :second :!pair/car :push sym/falsy? :call
         :push core-and-loop-false :branch
       :swap :!pair/cdr :swap
       :push core-and-loop :jump

:label core-and-loop-true
       :swap :pop :!T :swap :ret
:label core-and-loop-false
       :swap :pop :!F :swap :ret
)

;; Creates an or function that will leave T if any list element is not falsy,
;; otherwise F.
(proc  core/make-or
       :push 0x726f :push 0 :bufstore
       :push 0x0000 :push 1 :bufstore
       :push core/or
       :push core/create :call
       :ret
)

(proc  core/or
:label core-or-loop
       :second :!NIL :eq
         :push core-or-loop-false :branch
       :second :!pair/car :push sym/falsy? :call :!not
         :push core-or-loop-true :branch
       :swap :!pair/cdr :swap
       :push core-or-loop :jump

:label core-or-loop-true
       :swap :pop :!T :swap :ret
:label core-or-loop-false
       :swap :pop :!F :swap :ret
)

;; Creates an Not function that will leave T if the first list element is
;; falsy, otherwise F.
(proc  core/make-not
       :push 0x6f6e :push 0 :bufstore
       :push 0x0074 :push 1 :bufstore
       :push core/not
       :push core/create :call
       :ret
)

(proc  core/not
       :second :!NIL :eq
         :push core-not-no-arg :branch
       :swap :!pair/car :push sym/falsy? :call
       :push core/bool-to-T-F :call
       :swap :ret
:label core-not-no-arg
       :swap :pop :!T :swap :ret
)

;; Map, filter, reduce ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates a map symbol for a function that maps a function to a list of
;; arguments.
(proc  core/make-map
       :push 0x616d :push 0 :bufstore
       :push 0x0070 :push 1 :bufstore
       :push core/map
       :push core/create :call
       :ret
)

;; Expects an env and an evaluated argument list that starts with a subroutine
;; or a procedure and then a list of arguments to apply that procedure to.
;; Leaves the env and the new list.
(proc  core/map
       :push 0 :swap :rot
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :push core-map-args-error :branch
       :first :!pair/car ;; proc
       :swap :!pair/cdr :!pair/car ;; list
       :rot
:label core-map-apply-loop
       :second :!NIL :eq
         :push core-map-end :branch
       :second :!pair/car :!NIL
       :push pair/create :call
       :!fourth :swap :rot
       :push eval/apply-sub-or-proc :call
       :dswap :!pair/cdr :rot
       :push core-map-apply-loop :jump

:label core-map-end
       :rot :pop :rpush
       :push pair/create-list :call
       :rpop :ret
:label core-map-args-error
       :push map-args-error :prnmem-lb
       :pop :!ERROR :swap :ret
)

;; Creates a filter symbol for a function that filters a list of
;; arguments using a predicate.
(proc  core/make-filter
       :push 0x6966 :push 0 :bufstore
       :push 0x746c :push 1 :bufstore
       :push 0x7265 :push 2 :bufstore
       :push 0x0000 :push 3 :bufstore
       :push core/filter
       :push core/create :call
       :ret
)

;; Expects an env and an evaluated argument list that starts with a subroutine
;; or a procedure and then a list of arguments to filter with that procedure.
;; Leaves the env and the new list.
(proc  core/filter
       :push 0 :swap :rot
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :push core-filter-args-error :branch
       :first :!pair/car ;; proc
       :swap :!pair/cdr :!pair/car ;; list
       :rot
:label core-filter-apply-loop
       :second :push debug-form :call
       :second :!NIL :eq
         :push core-filter-end :branch
       :second :!pair/car :!NIL
       :push pair/create :call
       :!fourth :swap :rot
       :push eval/apply-sub-or-proc :call
       :second :push sym/falsy? :call
         :push core-filter-apply-discard :branch
       :swap :pop ;; remove bool
       :second :!pair/car :swap
       :dswap :!pair/cdr :rot
       :push core-filter-apply-loop :jump
:label core-filter-apply-discard
       :swap :pop :swap :!pair/cdr :swap
       :push core-filter-apply-loop :jump

:label core-filter-end
       :rot :pop :rpush
       :push pair/create-list :call
       :rpop :ret
:label core-filter-args-error
       :push filter-args-error :prnmem-lb
       :pop :!ERROR :swap :ret
)

;; Creates a reduce symbol for a function that uses a sub/proc to reduce a list
;; of arguments to a single value.
(proc  core/make-reduce
       :push 0x6572 :push 0 :bufstore
       :push 0x7564 :push 1 :bufstore
       :push 0x6563 :push 2 :bufstore
       :push 0x0000 :push 3 :bufstore
       :push core/reduce
       :push core/create :call
       :ret
)

;; Expects an env and an evaluated argument list that starts with a subroutine
;; or a procedure and then an initial value followed by a list of arguments to
;; reduce with the sub/proc and the initial value.
;; Leaves the env and the reduction.
(proc  core/reduce
       :swap
       :first :!NIL :eq
         :second :!pair/cdr :!NIL :eq
         :or :second :!pair/cdr :!pair/cdr :!NIL :eq
         :or :push core-reduce-args-error :branch
       :first :!pair/car ;; proc
       :second :!pair/cdr :!pair/car ;; initial
       :rot :!pair/cdr :!pair/cdr :!pair/car ;; list
       :dswap :rot :rot
:label core-reduce-apply-loop
       :second :!NIL :eq
         :push core-reduce-end :branch
       :push 0 :!fifth :!fourth :!pair/car :!NIL
       :push pair/create-list :call
       :!fourth :swap :rot
       :push eval/apply-sub-or-proc :call
       :rpush :rpush :!pair/cdr
       :rot :pop :rpop :rot :rot :rpop
       :push core-reduce-apply-loop :jump

:label core-reduce-end
       :swap :pop :swap :pop :ret
:label core-reduce-args-error
       :push reduce-args-error :prnmem-lb
       :pop :!ERROR :swap :ret
)

;; Creates a symbol for a function that will eval each form in a list of forms.
(proc  core/make-do
       :push 0x6f64 :push 0 :bufstore
       :push 0x0000 :push 1 :bufstore
       :push core/do
       :push core/create :call
       :ret
)

(proc  core/do
:label core-do-loop
       :second :!NIL :eq
         :push core-do-nil :branch
       :second :!pair/cdr :!NIL :eq
         :push core-do-end :branch
       :swap :!pair/cdr :swap
       :push core-do-loop :jump

:label core-do-nil
       :ret
:label core-do-end
       :swap :!pair/car :swap
       :ret
)

;; Eval, Apply, List ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates a  symbol for a function that evaluates a form.
(proc  core/make-eval
       :push 0x7665 :push 0 :bufstore
       :push 0x6c61 :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/eval
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments. Leaves the env and the evaluation
;; of the first argument.
(proc  core/eval
       :second :!NIL :eq
         :push core-eval-args-error :branch
       :swap :!pair/car :swap
       :push eval/form :call
       :ret
:label core-eval-args-error
       :push num-args-error-1 :prnmem-lb
       :push str-eval :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
)

;; Creates a  symbol for a function that creates a list from its arguments.
(proc  core/make-list
       :push 0x696c :push 0 :bufstore
       :push 0x7473 :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/list
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments. Leaves the env and the list of
;; arguments.
(proc  core/list
       ;; Does not have to do anything because eval/list already
       ;; created a list of the arguments.
       :ret
)

;; Creates a symbol for a function that applies sub/proc to a list as if the
;; list elements were arguments to the function. I.e. (apply add (2 3 4)) is
;; equivilent to (add 2 3 4).
(proc  core/make-apply
       :push 0x7061 :push 0 :bufstore
       :push 0x6c70 :push 1 :bufstore
       :push 0x0079 :push 2 :bufstore
       :push core/apply
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments. The first argument is a procedure
;; and the second argument is the list of arguments to the procedure. Leaves
;; the env and the application of the procedure to its list of arguments.
(proc  core/apply
       :second :!NIL :eq
         :!third :!pair/cdr :!NIL :eq
         :or :push core-apply-args-error :branch
       :second :!pair/car
       :rot :!pair/cdr :!pair/car
       :rot
       :push eval/apply-sub-or-proc :call
       :ret

:label core-apply-args-error
       :push num-args-error-2 :prnmem-lb
       :push str-apply :prnmem-lb :!prn-nl
       :swap :pop :!ERROR :swap :ret
)

;; Creates a symbol for a function that will load a file and evaluate all of
;; the forms in it.
(proc  core/make-load
       :push 0x6f6c :push 0 :bufstore
       :push 0x6461 :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/load
       :push core/create :call
       :ret
)

;; Takes an env, an empty list of arguments and expects a filename in the
;; buffer. Opens the file and evaluates the forms one by one, adding any
;; defines to the env. Leaves the updated env and NIL.
(proc  core/load
       :open
       :readch
:label core-load-loop
       :push read/eat-ws :call
       :eof?
         :push core-load-end :branch
       :push read/form :call
       ;; check for error
       ;; left the form address and the next char
       :!alloc/env-start
       :push eval/form :call
       ;; check for error
       :pop :pop
       :push core-load-loop :jump

:label core-load-end
       :close :reset-eof
       :pop :pop :pop
       :!NIL
       :!alloc/env-start
       :ret
)

;; NEED a compile function that dumps memory to a file in a way that it can
;; be loaded with the standalone vm. This will likely mean checking the program
;; length and then just dumping all memory, even if it is not used, as we do not
;; really know without running some kind of loop. Since the memory is only
;; 128k words it will not be to large of a file. For now it is fine.
;; For now the idea would be to put this after the *main* form in a file. Then
;; it will load all the defines when run and produce the output file, without
;; having the compile as part of the runnable program.

;; Creates a symbol for a function that will load a file and evaluate all of
;; the forms in it.
(proc  core/make-dump
       :push 0x7564 :push 0 :bufstore
       :push 0x706d :push 1 :bufstore
       :push 0x0000 :push 2 :bufstore
       :push core/dump
       :push core/create :call
       :ret
)

(proc  core/dump
       :push dump-start :prnmem-lb
       :bfp :wprn :!prn-nl
       :push dump-mid :prnmem-lb
       :!init-rcount
:label core-dump-loop
       :!rcount :push 20 :mod :!zero? :!not
         :!rcount :!zero?
         :or :push core-dump-no-newline :branch
       :push dump-newline :prnmem-lb
:label core-dump-no-newline
       :!rcount :load-lb :wprn
       :!ch-space :prnch
       ;; using next open only works if program has not done garbage collection
       :!rcount :!alloc/next-open :eq
         :push core-dump-loop-end :branch
       :!inc-rcount
       :push core-dump-loop :jump


:label core-dump-loop-end
       :!end-rcount
       :push dump-end :prnmem-lb
       :ret
)


;; I/O ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Creates a symbol for a function that will read a number from the current
;; input stream.
(proc  core/make-read-num
       :push 0x6572 :push 0 :bufstore
       :push 0x6461 :push 1 :bufstore
       :push 0x6e2d :push 2 :bufstore
       :push 0x6d75 :push 3 :bufstore
       :push core/read-num
       :push core/create :call
       :ret
)

;; Takes an env and a list of arguments and reads a number from the current
;; input stream. Leaves the env and the address of the new number.
(proc  core/read-num
       :readch
       :push read/eat-ws :call
       ;; error/eof checking
       :first :push read/starts-number? :call :!not
         :push read-num-invalid :branch
       :push read/number :call
       :swap :pop :swap :rot :pop
       :second :!ERROR :eq
         :push read-num-error-end :branch
       :ret

:label read-num-invalid
       :push invalid-number-start :prnmem-lb
       :first :prnch :!ch-lp :prnch :wprn :!ch-rp :prnch :!prn-nl
       :!ERROR :swap :rot :pop
:label read-num-error-end
       :readln :pop
       :ret
)

;; Creates a symbol for a function that will print a form as is.
(proc  core/make-prn
       :push 0x7270 :push 0 :bufstore
       :push 0x006e :push 1 :bufstore
       :push core/prn
       :push core/create :call
       :ret
)

(proc  core/prn
       :!true :push print-readable :store-lb
       :swap
       :first :!NIL :eq
         :push core-prn-form :branch
       :!pair/car
:label core-prn-form
       :push print/form :call
       :!NIL :swap :ret
)

;; Creates a symbol for a function that will print a form followed
;; by a newline.
(proc  core/make-prnln
       :push 0x7270 :push 0 :bufstore
       :push 0x6c6e :push 1 :bufstore
       :push 0x006e :push 2 :bufstore
       :push core/prnln
       :push core/create :call
       :ret
)

(proc  core/prnln
       :push core/prn :call
       :!prn-nl
       :ret
)

;; Creates a symbol for a function that will print a form with string chars
;; being printed for effect and not for the reader.
(proc  core/make-print
       :push 0x7270 :push 0 :bufstore
       :push 0x6e69 :push 1 :bufstore
       :push 0x0074 :push 2 :bufstore
       :push core/print
       :push core/create :call
       :ret
)

(proc  core/print
       :!false :push print-readable :store-lb
       :swap
       :first :!NIL :eq
         :push core-print-form :branch
       :!pair/car

:label core-print-form
       :push print/form :call
       :!true :push print-readable :store-lb
       :!NIL :swap :ret
)

;; Creates a symbol for a function that will print a form with string chars
;; being printed for effect and not for the reader.
(proc  core/make-println
       :push 0x7270 :push 0 :bufstore
       :push 0x6e69 :push 1 :bufstore
       :push 0x6c74 :push 2 :bufstore
       :push 0x006e :push 3 :bufstore
       :push core/println
       :push core/create :call
       :ret
)

(proc  core/println
       :push core/print :call
       :!prn-nl
       :ret
)

)
