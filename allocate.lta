(lt64-asm-mod
  ;; TODO eventually this needs to be more complex and ensure that the
  ;; next open memory will fit the data, as well as find the next open
  ;; slot. This doesn't matter before GC, but at that point unsued memory
  ;; needs to be reclaimed and used again by finding splitting and merging
  ;; open memory. The only way to avoid this is to find a way to make
  ;; all memory the same size, but I think symbols need at least 4 spaces
  ;; even if they just hold a pointer to the symbol print name, so 6 spaces
  ;; is easiest for splitting and merging to get the right sizes since everything
  ;; else is 3.

  ;; Heap managment ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Getters and setters for heap pointers
  ;; fmp + 0 = next open memory pointer
  ;; fmp + 1 = symtab head pointer
  ;; fmp + 2 = symtab tail pointer
  ;; fmp + 3 = symlist pointer
  (macro :!alloc/next-open :push 0 :load)
  (macro :!alloc/set-next-open :push 0 :store)

  (macro :!alloc/tab-head :push 1 :load)
  (macro :!alloc/set-tab-head :push 1 :store)

  (macro :!alloc/tab-tail :push 2 :load)
  (macro :!alloc/set-tab-tail :push 2 :store)

  (macro :!alloc/list-head :push 3 :load)
  (macro :!alloc/set-list-head :push 3 :store)

  ;; Setup the free memory portion of memory as a memory heap
  ;; Uses first 4 words for bookkeeping
  (proc alloc/setup-fm
    :fmp :push 4 :add :!alloc/set-next-open
    :fmp :push 2 :add :!alloc/set-tab-head
    :push 0 :!alloc/set-tab-tail
    :!builtin-syms-start :!alloc/set-list-head
    :ret)

  ;; Takes a size value of the stack and leaves the memory of the
  ;; newly allocated memory on top. Updates the heap pointer to the
  ;; memory after the new allocation.
  (proc alloc/alloc-size
    :!alloc/next-open
    :swap :second :add
    :!alloc/set-next-open
    :ret)

  ;; Allocate enough memory for most 'objects': dotted pairs, numbers, etc.
  (proc alloc/new-pair
    :push 3 :push alloc/alloc-size :call
    :ret)

  ;; Allocate enough memory for a new symbol and leave its address on stack
  (proc alloc/new-symbol
    :push 6 :push alloc/alloc-size :call
    :ret)
)
